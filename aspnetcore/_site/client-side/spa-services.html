<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Using JavaScriptServices for Creating Single Page Applications </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Using JavaScriptServices for Creating Single Page Applications ">
    <meta name="generator" content="docfx 2.24.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="client-side/spa-services">
<h1 id="using-javascriptservices-for-creating-single-page-applications-with-aspnet-core">Using JavaScriptServices for Creating Single Page Applications with ASP.NET Core</h1>

<p>By <a href="https://github.com/scottaddie">Scott Addie</a> and <a href="http://fiyazhasan.me/">Fiyaz Hasan</a></p>
<p>A Single Page Application (SPA) is a popular type of web application due to its inherent rich user experience. Integrating client-side SPA frameworks or libraries, such as <a href="https://angular.io/">Angular</a> or <a href="https://facebook.github.io/react/">React</a>, with server-side frameworks like ASP.NET Core can be difficult. <a href="https://github.com/aspnet/JavaScriptServices">JavaScriptServices</a> was developed to reduce friction in the integration process. It enables seamless operation between the different client and server technology stacks.</p>
<p><a href="https://github.com/aspnet/Docs/tree/master/aspnetcore/client-side/spa-services/sample">View or download sample code</a></p>
<p><a name="what-is-js-services"></a></p>
<h2 id="what-is-javascriptservices">What is JavaScriptServices?</h2>
<p>JavaScriptServices is a collection of client-side technologies for ASP.NET Core. Its goal is to position ASP.NET Core as developers&#39; preferred server-side platform for building SPAs.</p>
<p>JavaScriptServices consists of three distinct NuGet packages:</p>
<ul>
<li><a href="https://www.nuget.org/packages/Microsoft.AspNetCore.NodeServices/">Microsoft.AspNetCore.NodeServices</a> (NodeServices)</li>
<li><a href="https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices/">Microsoft.AspNetCore.SpaServices</a> (SpaServices)</li>
<li><a href="https://www.nuget.org/packages/Microsoft.AspNetCore.SpaTemplates/">Microsoft.AspNetCore.SpaTemplates</a> (SpaTemplates)</li>
</ul>
<p>These packages are useful if you:</p>
<ul>
<li>Run JavaScript on the server</li>
<li>Use a SPA framework or library</li>
<li>Build client-side assets with Webpack</li>
</ul>
<p>Much of the focus in this article is placed on using the SpaServices package.</p>
<p><a name="what-is-spa-services"></a></p>
<h2 id="what-is-spaservices">What is SpaServices?</h2>
<p>SpaServices was created to position ASP.NET Core as developers&#39; preferred server-side platform for building SPAs. SpaServices is not required to develop SPAs with ASP.NET Core, and it doesn&#39;t lock you into a particular client framework.</p>
<p>SpaServices provides useful infrastructure such as:</p>
<ul>
<li><a href="#server-prerendering">Server-side prerendering</a></li>
<li><a href="#webpack-dev-middleware">Webpack Dev Middleware</a></li>
<li><a href="#hot-module-replacement">Hot Module Replacement</a></li>
<li><a href="#routing-helpers">Routing helpers</a></li>
</ul>
<p>Collectively, these infrastructure components enhance both the development workflow and the runtime experience. The components can be adopted individually.</p>
<p><a name="spa-services-prereqs"></a></p>
<h2 id="prerequisites-for-using-spaservices">Prerequisites for using SpaServices</h2>
<p>To work with SpaServices, install the following:</p>
<ul>
<li><p><a href="https://nodejs.org/">Node.js</a> (version 6 or later) with npm</p>
<ul>
<li><p>To verify these components are installed and can be found, run the following from the command line:</p>
<pre><code class="lang-console">node -v &amp;&amp; npm -v
</code></pre></li>
</ul>
</li>
</ul>
<p>Note: If you&#39;re deploying to an Azure web site, you don&#39;t need to do anything here &mdash; Node.js is installed and available in the server environments.</p>
<ul>
<li><p><a href="https://www.microsoft.com/net/download/core">.NET Core SDK</a> 1.0 (or later)</p>
<ul>
<li>If you&#39;re on Windows, this can be installed by selecting Visual Studio 2017&#39;s <strong>.NET Core cross-platform development</strong> workload.</li>
</ul>
</li>
<li><p><a href="https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices/">Microsoft.AspNetCore.SpaServices</a> NuGet package</p>
</li>
</ul>
<p><a name="server-prerendering"></a></p>
<h2 id="server-side-prerendering">Server-side prerendering</h2>
<p>A universal (also known as isomorphic) application is a JavaScript application capable of running both on the server and the client. Angular, React, and other popular frameworks provide a universal platform for this application development style. The idea is to first render the framework components on the server via Node.js, and then delegate further execution to the client.</p>
<p>ASP.NET Core <a class="xref" href="../mvc/views/tag-helpers/intro.html">Tag Helpers</a> provided by SpaServices simplify the implementation of server-side prerendering by invoking the JavaScript functions on the server.</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>Install the following:</p>
<ul>
<li><p><a href="https://www.npmjs.com/package/aspnet-prerendering">aspnet-prerendering</a> npm package:</p>
<pre><code class="lang-console">npm i -S aspnet-prerendering
</code></pre></li>
</ul>
<h3 id="configuration">Configuration</h3>
<p>The Tag Helpers are made discoverable via namespace registration in the project&#39;s <em>_ViewImports.cshtml</em> file:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="3">@using SpaServicesSampleApp
@addTagHelper &quot;*, Microsoft.AspNetCore.Mvc.TagHelpers&quot;
@addTagHelper &quot;*, Microsoft.AspNetCore.SpaServices&quot;
</code></pre><p>These Tag Helpers abstract away the intricacies of communicating directly with low-level APIs by leveraging an HTML-like syntax inside the Razor view:</p>
<pre><code class="lang-html" name="Main">&lt;app asp-prerender-module=&quot;ClientApp/dist/main-server&quot;&gt;Loading...&lt;/app&gt;
</code></pre><h3 id="the-asp-prerender-module-tag-helper">The <code>asp-prerender-module</code> Tag Helper</h3>
<p>The <code>asp-prerender-module</code> Tag Helper, used in the preceding code example, executes <em>ClientApp/dist/main-server.js</em> on the server via Node.js. For clarity&#39;s sake, <em>main-server.js</em> file is an artifact of the TypeScript-to-JavaScript transpilation task in the <a href="http://webpack.github.io/">Webpack</a> build process. Webpack defines an entry point alias of <code>main-server</code>; and, traversal of the dependency graph for this alias begins at the <em>ClientApp/boot-server.ts</em> file:</p>
<pre><code class="lang-javascript" name="Main">entry: { &#39;main-server&#39;: &#39;./ClientApp/boot-server.ts&#39; },
</code></pre><p>In the following Angular example, the <em>ClientApp/boot-server.ts</em> file utilizes the <code>createServerRenderer</code> function and <code>RenderResult</code> type of the <code>aspnet-prerendering</code> npm package to configure server rendering via Node.js. The HTML markup destined for server-side rendering is passed to a resolve function call, which is wrapped in a strongly-typed JavaScript <code>Promise</code> object. The <code>Promise</code> object&#39;s significance is that it asynchronously supplies the HTML markup to the page for injection in the DOM&#39;s placeholder element.</p>
<pre><code class="lang-typescript" name="Main">import { createServerRenderer, RenderResult } from &#39;aspnet-prerendering&#39;;

export default createServerRenderer(params =&gt; {
    const providers = [
        { provide: INITIAL_CONFIG, useValue: { document: &#39;&lt;app&gt;&lt;/app&gt;&#39;, url: params.url } },
        { provide: &#39;ORIGIN_URL&#39;, useValue: params.origin }
    ];

    return platformDynamicServer(providers).bootstrapModule(AppModule).then(moduleRef =&gt; {
        const appRef = moduleRef.injector.get(ApplicationRef);
        const state = moduleRef.injector.get(PlatformState);
        const zone = moduleRef.injector.get(NgZone);
        
        return new Promise&lt;RenderResult&gt;((resolve, reject) =&gt; {
            zone.onError.subscribe(errorInfo =&gt; reject(errorInfo));
            appRef.isStable.first(isStable =&gt; isStable).subscribe(() =&gt; {
                // Because &#39;onStable&#39; fires before &#39;onError&#39;, we have to delay slightly before
                // completing the request in case there&#39;s an error to report
                setImmediate(() =&gt; {
                    resolve({
                        html: state.renderToString()
                    });
                    moduleRef.destroy();
                });
            });
        });
    });
});
</code></pre><h3 id="the-asp-prerender-data-tag-helper">The <code>asp-prerender-data</code> Tag Helper</h3>
<p>When coupled with the <code>asp-prerender-module</code> Tag Helper, the <code>asp-prerender-data</code> Tag Helper can be used to pass contextual information from the Razor view to the server-side JavaScript. For example, the following markup passes user data to the <code>main-server</code> module:</p>
<pre><code class="lang-html" name="Main">&lt;app asp-prerender-module=&quot;ClientApp/dist/main-server&quot;
        asp-prerender-data=&#39;new {
            UserName = &quot;John Doe&quot;
        }&#39;&gt;Loading...&lt;/app&gt;
</code></pre><p>The received <code>UserName</code> argument is serialized using the built-in JSON serializer and is stored in the <code>params.data</code> object. In the following Angular example, the data is used to construct a personalized greeting within an <code>h1</code> element:</p>
<pre><code class="lang-typescript" name="Main">import { createServerRenderer, RenderResult } from &#39;aspnet-prerendering&#39;;

export default createServerRenderer(params =&gt; {
    const providers = [
        { provide: INITIAL_CONFIG, useValue: { document: &#39;&lt;app&gt;&lt;/app&gt;&#39;, url: params.url } },
        { provide: &#39;ORIGIN_URL&#39;, useValue: params.origin }
    ];

    return platformDynamicServer(providers).bootstrapModule(AppModule).then(moduleRef =&gt; {
        const appRef = moduleRef.injector.get(ApplicationRef);
        const state = moduleRef.injector.get(PlatformState);
        const zone = moduleRef.injector.get(NgZone);
        
        return new Promise&lt;RenderResult&gt;((resolve, reject) =&gt; {
            const result = `&lt;h1&gt;Hello, ${params.data.userName}&lt;/h1&gt;`;

            zone.onError.subscribe(errorInfo =&gt; reject(errorInfo));
            appRef.isStable.first(isStable =&gt; isStable).subscribe(() =&gt; {
                // Because &#39;onStable&#39; fires before &#39;onError&#39;, we have to delay slightly before
                // completing the request in case there&#39;s an error to report
                setImmediate(() =&gt; {
                    resolve({
                        html: result
                    });
                    moduleRef.destroy();
                });
            });
        });
    });
});
</code></pre><p>Note: Property names passed in Tag Helpers are represented with <strong>PascalCase</strong> notation. Contrast that to JavaScript, where the same property names are represented with <strong>camelCase</strong>. The default JSON serialization configuration is responsible for this difference.</p>
<p>To expand upon the preceding code example, data can be passed from the server to the view by hydrating the <code>globals</code> property provided to the <code>resolve</code> function:</p>
<pre><code class="lang-typescript" name="Main">import { createServerRenderer, RenderResult } from &#39;aspnet-prerendering&#39;;

export default createServerRenderer(params =&gt; {
    const providers = [
        { provide: INITIAL_CONFIG, useValue: { document: &#39;&lt;app&gt;&lt;/app&gt;&#39;, url: params.url } },
        { provide: &#39;ORIGIN_URL&#39;, useValue: params.origin }
    ];

    return platformDynamicServer(providers).bootstrapModule(AppModule).then(moduleRef =&gt; {
        const appRef = moduleRef.injector.get(ApplicationRef);
        const state = moduleRef.injector.get(PlatformState);
        const zone = moduleRef.injector.get(NgZone);
        
        return new Promise&lt;RenderResult&gt;((resolve, reject) =&gt; {
            const result = `&lt;h1&gt;Hello, ${params.data.userName}&lt;/h1&gt;`;

            zone.onError.subscribe(errorInfo =&gt; reject(errorInfo));
            appRef.isStable.first(isStable =&gt; isStable).subscribe(() =&gt; {
                // Because &#39;onStable&#39; fires before &#39;onError&#39;, we have to delay slightly before
                // completing the request in case there&#39;s an error to report
                setImmediate(() =&gt; {
                    resolve({
                        html: result,
                        globals: {
                            postList: [
                                &#39;Introduction to ASP.NET Core&#39;,
                                &#39;Making apps with Angular and ASP.NET Core&#39;
                            ]
                        }
                    });
                    moduleRef.destroy();
                });
            });
        });
    });
});
</code></pre><p>The <code>postList</code> array defined inside the <code>globals</code> object is attached to the browser&#39;s global <code>window</code> object. This variable hoisting to global scope eliminates duplication of effort, particularly as it pertains to loading the same data once on the server and again on the client.</p>
<p><img src="spa-services/_static/global_variable.png" alt="global postList variable attached to window object"></p>
<p><a name="webpack-dev-middleware"></a></p>
<h2 id="webpack-dev-middleware">Webpack Dev Middleware</h2>
<p><a href="https://webpack.github.io/docs/webpack-dev-middleware.html">Webpack Dev Middleware</a> introduces a streamlined development workflow whereby Webpack builds resources on demand. The middleware automatically compiles and serves client-side resources when a page is reloaded in the browser. The alternate approach is to manually invoke Webpack via the project&#39;s npm build script when a third-party dependency or the custom code changes. An npm build script in the <em>package.json</em> file is shown in the following example:</p>
<pre><code class="lang-json" name="Main">&quot;build&quot;: &quot;npm run build:vendor &amp;&amp; npm run build:custom&quot;,
</code></pre><h3 id="prerequisites">Prerequisites</h3>
<p>Install the following:</p>
<ul>
<li><p><a href="https://www.npmjs.com/package/aspnet-webpack">aspnet-webpack</a> npm package:</p>
<pre><code class="lang-console">npm i -D aspnet-webpack
</code></pre></li>
</ul>
<h3 id="configuration">Configuration</h3>
<p>Webpack Dev Middleware is registered into the HTTP request pipeline via the following code in the <em>Startup.cs</em> file&#39;s <code>Configure</code> method:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="4">if (env.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
    app.UseWebpackDevMiddleware();
}
else
{
    app.UseExceptionHandler(&quot;/Home/Error&quot;);
}

// Call UseWebpackDevMiddleware before UseStaticFiles
app.UseStaticFiles();
</code></pre><p>The <code>UseWebpackDevMiddleware</code> extension method must be called before <a class="xref" href="../fundamentals/static-files.html">registering static file hosting</a> via the <code>UseStaticFiles</code> extension method. For security reasons, register the middleware only when the app runs in development mode.</p>
<p>The <em>webpack.config.js</em> file&#39;s <code>output.publicPath</code> property tells the middleware to watch the <code>dist</code> folder for changes:</p>
<pre><code class="lang-javascript" name="Main">module.exports = (env) =&gt; {
        output: {
            filename: &#39;[name].js&#39;,
            publicPath: &#39;/dist/&#39; // Webpack dev middleware, if enabled, handles requests for this URL prefix
        },
</code></pre><p><a name="hot-module-replacement"></a></p>
<h2 id="hot-module-replacement">Hot Module Replacement</h2>
<p>Think of Webpack&#39;s <a href="https://webpack.github.io/docs/hot-module-replacement-with-webpack.html">Hot Module Replacement</a> (HMR) feature as an evolution of <a href="#webpack-dev-middleware">Webpack Dev Middleware</a>. HMR introduces all the same benefits, but it further streamlines the development workflow by automatically updating page content after compiling the changes. Don&#39;t confuse this with a refresh of the browser, which would interfere with the current in-memory state and debugging session of the SPA. There is a live link between the Webpack Dev Middleware service and the browser, which means changes are ~simply another banned word~ pushed to the browser.</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>Install the following:</p>
<ul>
<li><p><a href="https://www.npmjs.com/package/webpack-hot-middleware">webpack-hot-middleware</a> npm package:</p>
<pre><code class="lang-console">npm i -D webpack-hot-middleware
</code></pre></li>
</ul>
<h3 id="configuration">Configuration</h3>
<p>The HMR component must be registered into MVC&#39;s HTTP request pipeline in the <code>Configure</code> method:</p>
<pre><code class="lang-csharp">app.UseWebpackDevMiddleware(new WebpackDevMiddlewareOptions {
    HotModuleReplacement = true
});
</code></pre><p>As was true with <a href="#webpack-dev-middleware">Webpack Dev Middleware</a>, the <code>UseWebpackDevMiddleware</code> extension method must be called before the <code>UseStaticFiles</code> extension method. For security reasons, register the middleware only when the app runs in development mode.</p>
<p>The <em>webpack.config.js</em> file must define a <code>plugins</code> array, even if it&#39;s left empty:</p>
<pre><code class="lang-javascript" name="Main">module.exports = (env) =&gt; {
        plugins: [new CheckerPlugin()]
</code></pre><p>After loading the app in the browser, the developer tools&#39; Console tab provides confirmation of HMR activation:</p>
<p><img src="spa-services/_static/hmr_connected.png" alt="Hot Module Replacement connected message"></p>
<p><a name="routing-helpers"></a></p>
<h2 id="routing-helpers">Routing helpers</h2>
<p>In most ASP.NET Core-based SPAs, you&#39;ll want client-side routing in addition to server-side routing. The SPA and MVC routing systems can work independently without interference. There is, however, one edge case posing challenges: identifying 404 HTTP responses.</p>
<p>Consider the scenario in which an extensionless route of <code>/some/page</code> is used. Assume the request doesn&#39;t pattern-match a server-side route, but its pattern does match a client-side route. Now consider an incoming request for <code>/images/user-512.png</code>, which generally expects to find an image file on the server. If that requested resource path doesn&#39;t match any server-side route or static file, it&#39;s unlikely that the client-side application would handle it — you generally want to return a 404 HTTP status code.</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>Install the following:</p>
<ul>
<li><p>The client-side routing npm package. Using Angular as an example:</p>
<pre><code class="lang-console">npm i -S @angular/router
</code></pre></li>
</ul>
<h3 id="configuration">Configuration</h3>
<p>An extension method named <code>MapSpaFallbackRoute</code> is used in the <code>Configure</code> method:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="7-9">app.UseMvc(routes =&gt;
{
    routes.MapRoute(
        name: &quot;default&quot;,
        template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);

    routes.MapSpaFallbackRoute(
        name: &quot;spa-fallback&quot;,
        defaults: new { controller = &quot;Home&quot;, action = &quot;Index&quot; });
});
</code></pre><p>Tip: Routes are evaluated in the order in which they&#39;re configured. Consequently, the <code>default</code> route in the preceding code example is used first for pattern matching.</p>
<p><a name="new-project-creation"></a></p>
<h2 id="creating-a-new-project">Creating a new project</h2>
<p>JavaScriptServices provides pre-configured application templates. SpaServices is used in these templates, in conjunction with different frameworks and libraries such as Angular, Aurelia, Knockout, React, and Vue.</p>
<p>These templates can be installed via the .NET Core CLI by running the following command:</p>
<pre><code class="lang-console">dotnet new --install Microsoft.AspNetCore.SpaTemplates::*
</code></pre><p>A list of available SPA templates is displayed:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Templates</th>
<th style="text-align:left">Short Name</th>
<th style="text-align:left">Language</th>
<th style="text-align:left">Tags</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">MVC ASP.NET Core with Angular</td>
<td style="text-align:left">angular</td>
<td style="text-align:left">[C#]</td>
<td style="text-align:left">Web/MVC/SPA</td>
</tr>
<tr>
<td style="text-align:left">MVC ASP.NET Core with Aurelia</td>
<td style="text-align:left">aurelia</td>
<td style="text-align:left">[C#]</td>
<td style="text-align:left">Web/MVC/SPA</td>
</tr>
<tr>
<td style="text-align:left">MVC ASP.NET Core with Knockout.js</td>
<td style="text-align:left">knockout</td>
<td style="text-align:left">[C#]</td>
<td style="text-align:left">Web/MVC/SPA</td>
</tr>
<tr>
<td style="text-align:left">MVC ASP.NET Core with React.js</td>
<td style="text-align:left">react</td>
<td style="text-align:left">[C#]</td>
<td style="text-align:left">Web/MVC/SPA</td>
</tr>
<tr>
<td style="text-align:left">MVC ASP.NET Core with React.js and Redux</td>
<td style="text-align:left">reactredux</td>
<td style="text-align:left">[C#]</td>
<td style="text-align:left">Web/MVC/SPA</td>
</tr>
<tr>
<td style="text-align:left">MVC ASP.NET Core with Vue.js</td>
<td style="text-align:left">vue</td>
<td style="text-align:left">[C#]</td>
<td style="text-align:left">Web/MVC/SPA</td>
</tr>
</tbody>
</table>
<p>To create a new project using one of the SPA templates, include the <strong>Short Name</strong> of the template in the <code>dotnet new</code> command. The following command creates an Angular application with ASP.NET Core MVC configured for the server side:</p>
<pre><code class="lang-console">dotnet new angular
</code></pre><p><a name="runtime-config-mode"></a></p>
<h3 id="set-the-runtime-configuration-mode">Set the runtime configuration mode</h3>
<p>Two primary runtime configuration modes exist:</p>
<ul>
<li><strong>Development</strong>:<ul>
<li>Includes source maps to ease debugging.</li>
<li>Doesn&#39;t optimize the client-side code for performance.</li>
</ul>
</li>
<li><strong>Production</strong>:<ul>
<li>Excludes source maps.</li>
<li>Optimizes the client-side code via bundling &amp; minification.</li>
</ul>
</li>
</ul>
<p>ASP.NET Core uses an environment variable named <code>ASPNETCORE_ENVIRONMENT</code> to store the configuration mode. See <strong><a class="xref" href="../fundamentals/environments.html#setting-the-environment">Setting the environment</a></strong> for more information.</p>
<h3 id="running-with-net-core-cli">Running with .NET Core CLI</h3>
<p>Restore the required NuGet and npm packages by running the following command at the project root:</p>
<pre><code class="lang-console">dotnet restore &amp;&amp; npm i
</code></pre><p>Build and run the application:</p>
<pre><code class="lang-console">dotnet run
</code></pre><p>The application starts on localhost according to the <a href="#runtime-config-mode">runtime configuration mode</a>. Navigating to <code>http://localhost:5000</code> in the browser displays the landing page.</p>
<h3 id="running-with-visual-studio-2017">Running with Visual Studio 2017</h3>
<p>Open the <em>.csproj</em> file generated by the <code>dotnet new</code> command. The required NuGet and npm packages are restored automatically upon project open. This restoration process may take up to a few minutes, and the application is ready to run when it completes. Click the green run button or press <code>Ctrl + F5</code>, and the browser opens to the application&#39;s landing page. The application runs on localhost according to the <a href="#runtime-config-mode">runtime configuration mode</a>. </p>
<p><a name="app-testing"></a></p>
<h2 id="testing-the-app">Testing the app</h2>
<p>SpaServices templates are pre-configured to run client-side tests using <a href="https://karma-runner.github.io/1.0/index.html">Karma</a> and <a href="https://jasmine.github.io/">Jasmine</a>. Jasmine is a popular unit testing framework for JavaScript, whereas Karma is a test runner for those tests. Karma is configured to work with the <a href="#webpack-dev-middleware">Webpack Dev Middleware</a> such that you don’t have to stop and run the test every time changes are made. Whether it&#39;s the code running against the test case or the test case itself, the test runs automatically.</p>
<p>Using the Angular application as an example, two Jasmine test cases are already provided for the <code>CounterComponent</code> in the <em>counter.component.spec.ts</em> file:</p>
<pre><code class="lang-typescript" name="Main">it(&#39;should display a title&#39;, async(() =&gt; {
    const titleText = fixture.nativeElement.querySelector(&#39;h1&#39;).textContent;
    expect(titleText).toEqual(&#39;Counter&#39;);
}));

it(&#39;should start with count 0, then increments by 1 when clicked&#39;, async(() =&gt; {
    const countElement = fixture.nativeElement.querySelector(&#39;strong&#39;);
    expect(countElement.textContent).toEqual(&#39;0&#39;);

    const incrementButton = fixture.nativeElement.querySelector(&#39;button&#39;);
    incrementButton.click();
    fixture.detectChanges();
    expect(countElement.textContent).toEqual(&#39;1&#39;);
}));
</code></pre><p>Open the command prompt at the project root, and run the following command:</p>
<pre><code class="lang-console">npm test
</code></pre><p>The script launches the Karma test runner, which reads the settings defined in the <em>karma.conf.js</em> file. Among other settings, the <em>karma.conf.js</em> identifies the test files to be executed via its <code>files</code> array:</p>
<pre><code class="lang-javascript" name="Main">module.exports = function (config) {
    config.set({
        files: [
            &#39;../../wwwroot/dist/vendor.js&#39;,
            &#39;./boot-tests.ts&#39;
        ],
</code></pre><p><a name="app-publishing"></a></p>
<h2 id="publishing-the-application">Publishing the application</h2>
<p>Combining the generated client-side assets and the published ASP.NET Core artifacts into a ready-to-deploy package can be cumbersome. Thankfully, SpaServices orchestrates that entire publication process with a custom MSBuild target named <code>RunWebpack</code>:</p>
<pre><code class="lang-xml" name="Main">&lt;Target Name=&quot;RunWebpack&quot; AfterTargets=&quot;ComputeFilesToPublish&quot;&gt;
  &lt;!-- As part of publishing, ensure the JS resources are freshly built in production mode --&gt;
  &lt;Exec Command=&quot;npm install&quot; /&gt;
  &lt;Exec Command=&quot;node node_modules/webpack/bin/webpack.js --config webpack.config.vendor.js --env.prod&quot; /&gt;
  &lt;Exec Command=&quot;node node_modules/webpack/bin/webpack.js --env.prod&quot; /&gt;

  &lt;!-- Include the newly-built files in the publish output --&gt;
  &lt;ItemGroup&gt;
    &lt;DistFiles Include=&quot;wwwroot\dist\**; ClientApp\dist\**&quot; /&gt;
    &lt;ResolvedFileToPublish Include=&quot;@(DistFiles-&gt;&#39;%(FullPath)&#39;)&quot; Exclude=&quot;@(ResolvedFileToPublish)&quot;&gt;
      &lt;RelativePath&gt;%(DistFiles.Identity)&lt;/RelativePath&gt;
      &lt;CopyToPublishDirectory&gt;PreserveNewest&lt;/CopyToPublishDirectory&gt;
    &lt;/ResolvedFileToPublish&gt;
  &lt;/ItemGroup&gt;
&lt;/Target&gt;
</code></pre><p>The MSBuild target has the following responsibilities:</p>
<ol>
<li>Restore the npm packages</li>
<li>Create a production-grade build of the third-party, client-side assets</li>
<li>Create a production-grade build of the custom client-side assets</li>
<li>Copy the Webpack-generated assets to the publish folder</li>
</ol>
<p>The MSBuild target is invoked when running:</p>
<pre><code class="lang-console">dotnet publish -c Release
</code></pre><h2 id="additional-resources">Additional resources</h2>
<ul>
<li><a href="https://angular.io/docs">Angular Docs</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/aspnet/Docs/blob/w/riande/RP-EF/aspnetcore/client-side/spa-services.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2015-2017 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
