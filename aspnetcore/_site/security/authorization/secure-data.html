<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Create an ASP.NET Core app with user data protected by authorization </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Create an ASP.NET Core app with user data protected by authorization ">
    <meta name="generator" content="docfx 2.24.0.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="security/authorization/secure-data">
<h1 id="create-an-aspnet-core-app-with-user-data-protected-by-authorization">Create an ASP.NET Core app with user data protected by authorization</h1>

<p>By <a href="https://twitter.com/RickAndMSFT">Rick Anderson</a> and <a href="https://twitter.com/joeaudette">Joe Audette</a></p>
<p>This tutorial shows how to create a web app with user data protected by authorization. It  displays a list of contacts that authenticated (registered) users have created. There are three security groups:</p>
<ul>
<li>Registered users can view all the approved contact data.</li>
<li>Registered users can edit/delete their own data. </li>
<li>Managers can approve or reject contact data. Only approved contacts are visible to users.</li>
<li>Administrators can approve/reject and edit/delete any data.</li>
</ul>
<p>In the following image, user Rick (<code>rick@example.com</code>) is signed in. User Rick can only view approved contacts and edit/delete his contacts. Only the last record, created by Rick, displays edit and delete links</p>
<p><img src="secure-data/_static/rick.png" alt="image described above"></p>
<p>In the following image, <code>manager@contoso.com</code> is signed in and in the managers role. </p>
<p><img src="secure-data/_static/manager1.png" alt="image described above"></p>
<p>The following image shows the  managers details view of a contact.</p>
<p><img src="secure-data/_static/manager.png" alt="image described above"></p>
<p>Only managers and administrators have the approve and reject buttons.</p>
<p>In the following image, <code>admin@contoso.com</code> is signed in and in the administrator’s role. </p>
<p><img src="secure-data/_static/admin.png" alt="image described above"></p>
<p>The administrator has all privileges. She can read/edit/delete any contact and change the status of contacts.</p>
<p>The app was created by <a class="xref" href="../../tutorials/first-mvc-app-xplat/adding-model.html#scaffold-the-moviecontroller">scaffolding</a>  the following <code>Contact</code> model:</p>
<pre><code class="lang-csharp" name="Main">public class Contact
{
    public int ContactId { get; set; }

    public string Name { get; set; }
    public string Address { get; set; }
    public string City { get; set; }
    public string State { get; set; }
    public string Zip { get; set; }
    public string Email { get; set; }
}
</code></pre><p>A <code>ContactIsOwnerAuthorizationHandler</code> authorization handler ensures that a user can only edit their data. A <code>ContactManagerAuthorizationHandler</code> authorization handler allows managers to approve or reject contacts.  A <code>ContactAdministratorsAuthorizationHandler</code> authorization handler allows administrators to approve or reject contacts and to edit/delete contacts. </p>
<h2 id="prerequisites">Prerequisites</h2>
<p>This is not a beginning tutorial. You should be familiar with:</p>
<ul>
<li><a class="xref" href="../../tutorials/first-mvc-app/start-mvc.html">ASP.NET Core MVC</a></li>
<li><a class="xref" href="../../data/ef-mvc/intro.html">Entity Framework Core</a></li>
</ul>
<h2 id="the-starter-and-completed-app">The starter and completed app</h2>
<p><a class="xref" href="../../tutorials/index.html#how-to-download-a-sample">Download</a> the <a href="https://github.com/aspnet/Docs/tree/master/aspnetcore/security/authorization/secure-data/samples/final">completed</a> app. <a href="#test-the-completed-app">Test</a> the completed app so you become familiar with its security features. </p>
<h3 id="the-starter-app">The starter app</h3>
<p>It&#39;s helpful to compare your code with the completed sample.</p>
<p><a class="xref" href="../../tutorials/index.html#how-to-download-a-sample">Download</a> the <a href="https://github.com/aspnet/Docs/tree/master/aspnetcore/security/authorization/secure-data/samples/starter">starter</a> app. </p>
<p>See <a href="#create-the-starter-app">Create the starter app</a> if you&#39;d like to create it from scratch.</p>
<p>Update the database:</p>
<pre><code class="lang-none">   dotnet ef database update
</code></pre><p>Run the app, tap the <strong>ContactManager</strong> link, and verify you can create, edit, and delete a contact.</p>
<p>This tutorial has all the major steps to create the secure user data app. You may find it helpful to refer to the completed project.</p>
<h2 id="modify-the-app-to-secure-user-data">Modify the app to secure user data</h2>
<p>The following sections have all the major steps to create the secure user data app. You may find it helpful to refer to the completed project.</p>
<h3 id="tie-the-contact-data-to-the-user">Tie the contact data to the user</h3>
<p>Use the ASP.NET <a class="xref" href="../authentication/identity.html">Identity</a> user ID to ensure users can edit their data, but not other users data. Add <code>OwnerID</code> to the <code>Contact</code> model:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="5-6,16-">public class Contact
{
    public int ContactId { get; set; }

    // user ID from AspNetUser table
    public string OwnerID { get; set; }

    public string Name { get; set; }
    public string Address { get; set; }
    public string City { get; set; }
    public string State { get; set; }
    public string Zip { get; set; }
    [DataType(DataType.EmailAddress)]
    public string Email { get; set; }

    public ContactStatus Status { get; set; }
}

public enum ContactStatus
{
    Submitted,
    Approved,
    Rejected
}
</code></pre><p><code>OwnerID</code> is the user&#39;s ID from the <code>AspNetUser</code> table in the <a class="xref" href="../authentication/identity.html">Identity</a> database. The <code>Status</code> field determines if a contact is viewable by general users. </p>
<p>Scaffold a new migration and update the database:</p>
<pre><code class="lang-console">dotnet ef migrations add userID_Status
dotnet ef database update
</code></pre><h3 id="require-ssl-and-authenticated-users">Require SSL and authenticated users</h3>
<p>In the <code>ConfigureServices</code> method of the <em>Startup.cs</em> file, add the <a href="/aspnet/core/api/microsoft.aspnetcore.mvc.requirehttpsattribute">RequireHttpsAttribute</a> authorization filter:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="1">var skipSSL = Configuration.GetValue&lt;bool&gt;(&quot;LocalTest:skipSSL&quot;);
// requires using Microsoft.AspNetCore.Mvc;
services.Configure&lt;MvcOptions&gt;(options =&gt;
{
// Set LocalTest:skipSSL to true to skip SSL requrement in 
// debug mode. This is useful when not using Visual Studio.
if (_hostingEnv.IsDevelopment() &amp;&amp; !skipSSL)
    {
        options.Filters.Add(new RequireHttpsAttribute());
    }
});
</code></pre><p>To redirect HTTP requests to HTTPS, see <a class="xref" href="../../fundamentals/url-rewriting.html">URL Rewriting Middleware</a>. If you are using Visual Studio Code or testing on local platform that doesn&#39;t include a test certificate for SSL:</p>
<ul>
<li>Set <code>&quot;LocalTest:skipSSL&quot;: true</code> in the <em>appsettings.json</em> file.</li>
</ul>
<h3 id="require-authenticated-users">Require authenticated users</h3>
<p>Set the default authentication policy to require users to be authenticated. You can opt out of authentication at the controller or action method with the <code>[AllowAnonymous]</code> attribute. With this approach, any new controllers added will automatically require authentication, which is safer than relying on new controllers to include the <code>[Authorize]</code> attribute. Add the following to  the <code>ConfigureServices</code> method of the <em>Startup.cs</em> file:</p>
<pre><code class="lang-csharp" name="Main">// requires: using Microsoft.AspNetCore.Authorization;
//           using Microsoft.AspNetCore.Mvc.Authorization;
services.AddMvc(config =&gt;
{
    var policy = new AuthorizationPolicyBuilder()
                     .RequireAuthenticatedUser()
                     .Build();
    config.Filters.Add(new AuthorizeFilter(policy));
});
</code></pre><p>Add <code>[AllowAnonymous]</code> to the home controller so anonymous users can get information about the site before they register.</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="2,6">using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;

namespace ContactManager.Controllers
{
    [AllowAnonymous]
    public class HomeController : Controller
    {
        public IActionResult Index()
        {
            return View();
        }
</code></pre><h3 id="configure-the-test-account">Configure the test account</h3>
<p>The <code>SeedData</code> class creates two accounts,  administrator and manager. Use the <a class="xref" href="../app-secrets.html">Secret Manager tool</a> to set a password for these accounts. Do this from the project directory (the directory containing <em>Program.cs</em>).</p>
<pre><code class="lang-console">dotnet user-secrets set SeedUserPW &lt;PW&gt;
</code></pre><p>Update <code>Configure</code> to use the test password:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="19-21">public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
        app.UseDatabaseErrorPage();
    }
    else
    {
        app.UseExceptionHandler(&quot;/Home/Error&quot;);
    }

    app.UseStaticFiles();

    app.UseIdentity();

    app.UseMvcWithDefaultRoute();

    // Set password with the Secret Manager tool.
    // dotnet user-secrets set SeedUserPW &lt;pw&gt;
    var testUserPw = Configuration[&quot;SeedUserPW&quot;];

    if (String.IsNullOrEmpty(testUserPw))
    {
        throw new System.Exception(&quot;Use secrets manager to set SeedUserPW \n&quot; +
                                   &quot;dotnet user-secrets set SeedUserPW &lt;pw&gt;&quot;);
    }

    try
    {
        SeedData.Initialize(app.ApplicationServices, testUserPw).Wait();
    }
    catch
    {
        throw new System.Exception(&quot;You need to update the DB &quot;
            + &quot;\nPM &gt; Update-Database &quot; + &quot;\n or \n&quot; +
              &quot;&gt; dotnet ef database update&quot;
              + &quot;\nIf that doesn&#39;t work, comment out SeedData and &quot;
              + &quot;register a new user&quot;);
    }
</code></pre><p>Add the administrator user ID and <code>Status = ContactStatus.Approved</code> to the contacts. Only one contact is shown, add the user ID to all contacts:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="17,18">public static void SeedDB(ApplicationDbContext context, string adminID)
{
    if (context.Contact.Any())
    {
        return;   // DB has been seeded
    }

    context.Contact.AddRange(
        new Contact
        {
            Name = &quot;Debra Garcia&quot;,
            Address = &quot;1234 Main St&quot;,
            City = &quot;Redmond&quot;,
            State = &quot;WA&quot;,
            Zip = &quot;10999&quot;,
            Email = &quot;debra@example.com&quot;,
            Status = ContactStatus.Approved,
            OwnerID = adminID
        },
</code></pre><h2 id="create-owner-manager-and-administrator-authorization-handlers">Create owner, manager, and administrator authorization handlers</h2>
<p>Create a <code>ContactIsOwnerAuthorizationHandler</code> class in the  <em>Authorization</em> folder. The <code>ContactIsOwnerAuthorizationHandler</code> will verify the user acting on the resource owns the resource.</p>
<pre><code class="lang-csharp" name="Main">using System.Threading.Tasks;
using ContactManager.Models;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Authorization.Infrastructure;
using Microsoft.AspNetCore.Identity;

namespace ContactManager.Authorization
{
    public class ContactIsOwnerAuthorizationHandler
                : AuthorizationHandler&lt;OperationAuthorizationRequirement, Contact&gt;
    {
        UserManager&lt;ApplicationUser&gt; _userManager;

        public ContactIsOwnerAuthorizationHandler(UserManager&lt;ApplicationUser&gt; 
            userManager)
        {
            _userManager = userManager;
        }

        protected override Task
            HandleRequirementAsync(AuthorizationHandlerContext context,
                                   OperationAuthorizationRequirement requirement,
                                   Contact resource)
        {
            if (context.User == null || resource == null)
            {
                return Task.FromResult(0);
            }

            // If we&#39;re not asking for CRUD permission, return.

            if (requirement.Name != Constants.CreateOperationName &amp;&amp;
                requirement.Name != Constants.ReadOperationName   &amp;&amp;
                requirement.Name != Constants.UpdateOperationName &amp;&amp;
                requirement.Name != Constants.DeleteOperationName )
            {
                return Task.FromResult(0);
            }

            if (resource.OwnerID == _userManager.GetUserId(context.User))
            {
                context.Succeed(requirement);
            }

            return Task.FromResult(0);
        }
    }
}
</code></pre><p>The <code>ContactIsOwnerAuthorizationHandler</code> calls <code>context.Succeed</code> if the current authenticated user is the contact owner. Authorization handlers generally return <code>context.Succeed</code> when the requirements are met. They return <code>Task.FromResult(0)</code> when requirements are not met. <code>Task.FromResult(0)</code> is neither success or failure, it allows other authorization handler to run. If you need to explicitly fail, return <code>context.Fail()</code>.</p>
<p>We allow contact owners to edit/delete their own data, so we don&#39;t need to check the operation passed in the requirement parameter.</p>
<h3 id="create-a-manager-authorization-handler">Create a manager authorization handler</h3>
<p>Create a <code>ContactManagerAuthorizationHandler</code> class in the  <em>Authorization</em> folder. The <code>ContactManagerAuthorizationHandler</code> will verify the user acting on the resource is a manager. Only managers can approve or reject content changes (new or changed).</p>
<pre><code class="lang-csharp" name="Main">using System.Threading.Tasks;
using ContactManager.Models;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Authorization.Infrastructure;
using Microsoft.AspNetCore.Identity;

namespace ContactManager.Authorization
{
    public class ContactManagerAuthorizationHandler :
        AuthorizationHandler&lt;OperationAuthorizationRequirement, Contact&gt;
    {
        protected override Task
            HandleRequirementAsync(AuthorizationHandlerContext context,
                                   OperationAuthorizationRequirement requirement,
                                   Contact resource)
        {
            if (context.User == null || resource == null)
            {
                return Task.FromResult(0);
            }

            // If not asking for approval/reject, return.
            if (requirement.Name != Constants.ApproveOperationName &amp;&amp;
                requirement.Name != Constants.RejectOperationName)
            {
                return Task.FromResult(0);
            }

            // Managers can approve or reject.
            if (context.User.IsInRole(Constants.ContactManagersRole))
            {
                context.Succeed(requirement);
            }

            return Task.FromResult(0);
        }
    }
}
</code></pre><h3 id="create-an-administrator-authorization-handler">Create an administrator authorization handler</h3>
<p>Create a <code>ContactAdministratorsAuthorizationHandler</code> class in the  <em>Authorization</em> folder. The <code>ContactAdministratorsAuthorizationHandler</code> will verify the user acting on the resource is a administrator. Administrator can do all operations.</p>
<pre><code class="lang-csharp" name="Main">using System.Threading.Tasks;
using ContactManager.Models;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Authorization.Infrastructure;

namespace ContactManager.Authorization
{
    public class ContactAdministratorsAuthorizationHandler
                    : AuthorizationHandler&lt;OperationAuthorizationRequirement, Contact&gt;
    {
        protected override Task HandleRequirementAsync(
                                              AuthorizationHandlerContext context,
                                    OperationAuthorizationRequirement requirement, 
                                     Contact resource)
        {
            if (context.User == null)
            {
                return Task.FromResult(0);
            }

            // Administrators can do anything.
            if (context.User.IsInRole(Constants.ContactAdministratorsRole))
            {
                context.Succeed(requirement);
            }

            return Task.FromResult(0);
        }
    }
}
</code></pre><h2 id="register-the-authorization-handlers">Register the authorization handlers</h2>
<p>Services using Entity Framework Core must be registered for <a class="xref" href="../../fundamentals/dependency-injection.html">dependency injection</a> using <a href="/aspnet/core/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions">AddScoped</a>. The <code>ContactIsOwnerAuthorizationHandler</code> uses ASP.NET Core <a class="xref" href="../authentication/identity.html">Identity</a>, which is built on Entity Framework Core. Register the handlers with the service collection so they will be available to the <code>ContactsController</code> through <a class="xref" href="../../fundamentals/dependency-injection.html">dependency injection</a>. Add the following code to the end of <code>ConfigureServices</code>:</p>
<pre><code class="lang-csharp" name="Main">// Authorization handlers.
services.AddScoped&lt;IAuthorizationHandler,
                      ContactIsOwnerAuthorizationHandler&gt;();

services.AddSingleton&lt;IAuthorizationHandler,
                      ContactAdministratorsAuthorizationHandler&gt;();

services.AddSingleton&lt;IAuthorizationHandler,
                      ContactManagerAuthorizationHandler&gt;();
</code></pre><p><code>ContactAdministratorsAuthorizationHandler</code> and <code>ContactManagerAuthorizationHandler</code> are added as singletons. They are singletons because they don&#39;t use EF and all the information needed is in the <code>Context</code> parameter of the <code>HandleRequirementAsync</code> method.</p>
<p>The complete <code>ConfigureServices</code>:</p>
<pre><code class="lang-csharp" name="Main">public void ConfigureServices(IServiceCollection services)
{
    // Add framework services.
    services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
        options.UseSqlServer(Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));

    services.AddIdentity&lt;ApplicationUser, IdentityRole&gt;()
        .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()
        .AddDefaultTokenProviders();

    services.AddMvc();

    // Add application services.
    services.AddTransient&lt;IEmailSender, AuthMessageSender&gt;();
    services.AddTransient&lt;ISmsSender, AuthMessageSender&gt;();

    var skipSSL = Configuration.GetValue&lt;bool&gt;(&quot;LocalTest:skipSSL&quot;);
    // requires using Microsoft.AspNetCore.Mvc;
    services.Configure&lt;MvcOptions&gt;(options =&gt;
    {
    // Set LocalTest:skipSSL to true to skip SSL requrement in 
    // debug mode. This is useful when not using Visual Studio.
    if (_hostingEnv.IsDevelopment() &amp;&amp; !skipSSL)
        {
            options.Filters.Add(new RequireHttpsAttribute());
        }
    });

    // requires: using Microsoft.AspNetCore.Authorization;
    //           using Microsoft.AspNetCore.Mvc.Authorization;
    services.AddMvc(config =&gt;
    {
        var policy = new AuthorizationPolicyBuilder()
                         .RequireAuthenticatedUser()
                         .Build();
        config.Filters.Add(new AuthorizeFilter(policy));
    });

    // Authorization handlers.
    services.AddScoped&lt;IAuthorizationHandler,
                          ContactIsOwnerAuthorizationHandler&gt;();

    services.AddSingleton&lt;IAuthorizationHandler,
                          ContactAdministratorsAuthorizationHandler&gt;();

    services.AddSingleton&lt;IAuthorizationHandler,
                          ContactManagerAuthorizationHandler&gt;();
}
</code></pre><h2 id="update-the-code-to-support-authorization">Update the code to support authorization</h2>
<p>In this section, you update the controller and views and add an operations requirements class.</p>
<h3 id="update-the-contacts-controller">Update the Contacts controller</h3>
<p>Update the <code>ContactsController</code> constructor:</p>
<ul>
<li>Add the <code>IAuthorizationService</code> service to  access to the authorization handlers. </li>
<li>Add the <code>Identity</code> <code>UserManager</code> service:</li>
</ul>
<pre><code class="lang-csharp" name="Main">public class ContactsController : Controller
{
    private readonly ApplicationDbContext _context;
    private readonly IAuthorizationService _authorizationService;
    private readonly UserManager&lt;ApplicationUser&gt; _userManager;

    public ContactsController(
        ApplicationDbContext context,
        IAuthorizationService authorizationService,
        UserManager&lt;ApplicationUser&gt; userManager)
    {
        _context = context;
        _userManager = userManager;
        _authorizationService = authorizationService;
    }
</code></pre><h3 id="add-a-contact-operations-requirements-class">Add a contact operations requirements class</h3>
<p>Add the <code>ContactOperationsRequirements</code> class to the <em>Authorization</em> folder. This class  contain the requirements our app supports:</p>
<pre><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Authorization.Infrastructure;

namespace ContactManager.Authorization
{
    public static class ContactOperations
    {
        public static OperationAuthorizationRequirement Create =   
          new OperationAuthorizationRequirement {Name=Constants.CreateOperationName};
        public static OperationAuthorizationRequirement Read = 
          new OperationAuthorizationRequirement {Name=Constants.ReadOperationName};  
        public static OperationAuthorizationRequirement Update = 
          new OperationAuthorizationRequirement {Name=Constants.UpdateOperationName}; 
        public static OperationAuthorizationRequirement Delete = 
          new OperationAuthorizationRequirement {Name=Constants.DeleteOperationName};
        public static OperationAuthorizationRequirement Approve = 
          new OperationAuthorizationRequirement {Name=Constants.ApproveOperationName};
        public static OperationAuthorizationRequirement Reject = 
          new OperationAuthorizationRequirement {Name=Constants.RejectOperationName};
    }

    public class Constants
    {
        public static readonly string CreateOperationName = &quot;Create&quot;;
        public static readonly string ReadOperationName = &quot;Read&quot;;
        public static readonly string UpdateOperationName = &quot;Update&quot;;
        public static readonly string DeleteOperationName = &quot;Delete&quot;;
        public static readonly string ApproveOperationName = &quot;Approve&quot;;
        public static readonly string RejectOperationName = &quot;Reject&quot;;

        public static readonly string ContactAdministratorsRole = 
                                                              &quot;ContactAdministrators&quot;;
        public static readonly string ContactManagersRole = &quot;ContactManagers&quot;;
    }
}
</code></pre><h3 id="update-create">Update Create</h3>
<p>Update the <code>HTTP POST Create</code> method to:</p>
<ul>
<li>Add the user ID to the <code>Contact</code> model.</li>
<li>Call the authorization handler to verify the user owns the contact.</li>
</ul>
<pre><code class="lang-csharp" name="Main">// POST: Contacts/Create
[HttpPost]
[ValidateAntiForgeryToken]
public async Task&lt;IActionResult&gt; Create(ContactEditViewModel editModel)
{
    if (!ModelState.IsValid)
    {
        return View(editModel);
    }

    var contact = ViewModel_to_model(new Contact(), editModel);

    contact.OwnerID = _userManager.GetUserId(User);

    var isAuthorized = await _authorizationService.AuthorizeAsync(
                                                User, contact,
                                                ContactOperations.Create);
    if (!isAuthorized)
    {
        return new ChallengeResult();
    }

    _context.Add(contact);
    await _context.SaveChangesAsync();
    return RedirectToAction(&quot;Index&quot;);
}
</code></pre><h3 id="update-edit">Update Edit</h3>
<p>Update both <code>Edit</code> methods to use the authorization handler to verify the user owns the contact. Because we are performing resource authorization we cannot use the <code>[Authorize]</code> attribute. We don&#39;t have access to the resource when attributes are evaluated. Resource based authorization must be imperative. Checks must be performed once we have access to the resource, either by loading it in our controller, or by loading it within the handler itself. Frequently you will access the resource by passing in the resource key.</p>
<pre><code class="lang-csharp" name="Main">public async Task&lt;IActionResult&gt; Edit(int? id)
{
    if (id == null)
    {
        return NotFound();
    }

    var contact = await _context.Contact.SingleOrDefaultAsync(
                                                m =&gt; m.ContactId == id);
    if (contact == null)
    {
        return NotFound();
    }

    var isAuthorized = await _authorizationService.AuthorizeAsync(
                                                User, contact,
                                                ContactOperations.Update);
    if (!isAuthorized)
    {
        return new ChallengeResult();
    }

    var editModel = Model_to_viewModel(contact);

    return View(editModel);
}

// POST: Contacts/Edit/5
[HttpPost]
[ValidateAntiForgeryToken]
public async Task&lt;IActionResult&gt; Edit(int id, ContactEditViewModel editModel)
{
    if (!ModelState.IsValid)
    {
        return View(editModel);
    }

    // Fetch Contact from DB to get OwnerID.
    var contact = await _context.Contact.SingleOrDefaultAsync(m =&gt; m.ContactId == id);
    if (contact == null)
    {
        return NotFound();
    }

    var isAuthorized = await _authorizationService.AuthorizeAsync(User, contact,
                                                        ContactOperations.Update);
    if (!isAuthorized)
    {
        return new ChallengeResult();
    }

    contact = ViewModel_to_model(contact, editModel);

    if (contact.Status == ContactStatus.Approved)
    {
        // If the contact is updated after approval, 
        // and the user cannot approve set the status back to submitted
        var canApprove = await _authorizationService.AuthorizeAsync(User, contact,
                                ContactOperations.Approve);

        if (!canApprove) contact.Status = ContactStatus.Submitted;
    }

    _context.Update(contact);
    await _context.SaveChangesAsync();

    return RedirectToAction(&quot;Index&quot;);
}
</code></pre><h3 id="update-the-delete-method">Update the Delete method</h3>
<p>Update both <code>Delete</code> methods to use the authorization handler to verify the user owns the contact.</p>
<pre><code class="lang-csharp" name="Main">public async Task&lt;IActionResult&gt; Delete(int? id)
{
    if (id == null)
    {
        return NotFound();
    }

    var contact = await _context.Contact.SingleOrDefaultAsync(m =&gt; m.ContactId == id);
    if (contact == null)
    {
        return NotFound();
    }

    var isAuthorized = await _authorizationService.AuthorizeAsync(User, contact,
                                ContactOperations.Delete);
    if (!isAuthorized)
    {
        return new ChallengeResult();
    }

    return View(contact);
}

// POST: Contacts/Delete/5
[HttpPost, ActionName(&quot;Delete&quot;)]
[ValidateAntiForgeryToken]
public async Task&lt;IActionResult&gt; DeleteConfirmed(int id)
{
    var contact = await _context.Contact.SingleOrDefaultAsync(m =&gt; m.ContactId == id);

    var isAuthorized = await _authorizationService.AuthorizeAsync(User, contact,
                                ContactOperations.Delete);
    if (!isAuthorized)
    {
        return new ChallengeResult();
    }

    _context.Contact.Remove(contact);
    await _context.SaveChangesAsync();
    return RedirectToAction(&quot;Index&quot;);
}
</code></pre><h2 id="inject-the-authorization-service-into-the-views">Inject the authorization service into the views</h2>
<p>Currently the UI shows edit and delete links for data the user cannot modify. We&#39;ll fix that by applying the authorization handler to the views.</p>
<p>Inject the authorization service in the <em>Views/_ViewImports.cshtml</em> file so it will be available to all views:</p>
<pre><code class="lang-html" name="Main">@using ContactManager
@using ContactManager.Models
@using ContactManager.Models.AccountViewModels
@using ContactManager.Models.ManageViewModels
@using ContactManager.Authorization
@using Microsoft.AspNetCore.Identity
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
@using Microsoft.AspNetCore.Authorization
@inject IAuthorizationService AuthorizationService 
</code></pre><p>Update the <em>Views/Contacts/Index.cshtml</em> Razor view to only display the edit and delete links for users who can edit/delete the contact.</p>
<p>Add <code>@using ContactManager.Authorization;</code></p>
<p>Update the <code>Edit</code> and <code>Delete</code> links so they are only rendered for users with permission to edit and delete the contact.</p>
<pre><code class="lang-html" name="Main">    &lt;/td&gt;
    &lt;td&gt;
        @Html.DisplayFor(modelItem =&gt; item.Zip)
    &lt;/td&gt;
    &lt;td&gt;
        @Html.DisplayFor(modelItem =&gt; item.Status)
    &lt;/td&gt;
    &lt;td&gt;
        @if (await AuthorizationService.AuthorizeAsync(User,
                                           item, ContactOperations.Update))
        {
            &lt;a asp-action=&quot;Edit&quot; asp-route-id=&quot;@item.ContactId&quot;&gt;Edit&lt;/a&gt;&lt;text&gt; | &lt;/text&gt;
        }
        &lt;a asp-action=&quot;Details&quot; asp-route-id=&quot;@item.ContactId&quot;&gt;Details&lt;/a&gt;
        @if (await AuthorizationService.AuthorizeAsync(User,
                                             item, ContactOperations.Delete))
        {
            &lt;text&gt; | &lt;/text&gt;
            &lt;a asp-action=&quot;Delete&quot; asp-route-id=&quot;@item.ContactId&quot;&gt;Delete&lt;/a&gt;
        }
    &lt;/td&gt;
&lt;/tr&gt;
</code></pre><p>Warning: Hiding links from users that do not have permission to edit or delete data does not secure the app. Hiding links makes the app more user friendly by displaying only valid links. Users can hack the generated URLs to invoke edit and delete operations on data they don&#39;t own.  The controller must repeat the access checks to be secure.</p>
<h3 id="update-the-details-view">Update the Details view</h3>
<p>Update the details view so managers can approve or reject contacts:</p>
<pre><code class="lang-html" name="Main">        &lt;dt&gt;
            @Html.DisplayNameFor(model =&gt; model.Zip)
        &lt;/dt&gt;
        &lt;dd&gt;
            @Html.DisplayFor(model =&gt; model.Zip)
        &lt;/dd&gt;
        &lt;dt&gt;
            @Html.DisplayNameFor(model =&gt; model.Status)
        &lt;/dt&gt;
        &lt;dd&gt;
            @Html.DisplayFor(model =&gt; model.Status)
        &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;
@if (Model.Status != ContactStatus.Approved)
{
    @if (await AuthorizationService.AuthorizeAsync(User, Model, ContactOperations.Approve))
    {
        &lt;form asp-action=&quot;SetStatus&quot; asp-controller=&quot;Contacts&quot; style=&quot;display:inline;&quot;&gt;
            &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;@Model.ContactId&quot; /&gt;
            &lt;input type=&quot;hidden&quot; name=&quot;status&quot; value=&quot;@ContactStatus.Approved&quot; /&gt;
            &lt;button type=&quot;submit&quot; class=&quot;btn btn-xs btn-success&quot;&gt;Approve&lt;/button&gt;
        &lt;/form&gt;
    }  
}
@if (Model.Status != ContactStatus.Rejected)
{
    @if (await AuthorizationService.AuthorizeAsync(User, Model, ContactOperations.Reject))
    {
        &lt;form asp-action=&quot;SetStatus&quot; asp-controller=&quot;Contacts&quot; style=&quot;display:inline;&quot;&gt;
            &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;@Model.ContactId&quot; /&gt;
            &lt;input type=&quot;hidden&quot; name=&quot;status&quot; value=&quot;@ContactStatus.Rejected&quot; /&gt;
            &lt;button type=&quot;submit&quot; class=&quot;btn btn-xs btn-danger&quot;&gt;Reject&lt;/button&gt;
        &lt;/form&gt;
    }
}
&lt;div&gt;
@* Uncomment to perform authorization check. A real app would hide the edit link from users
        uses who don&#39;t have edit access. A user without edit access can click the link but will get denied 
        access in the controller.  
    @if(await AuthorizationService.AuthorizeAsync(User, Model, ContactOperations.Update))
    {
*@
        &lt;a asp-action=&quot;Edit&quot; asp-route-id=&quot;@Model.ContactId&quot;&gt;Edit&lt;/a&gt; &lt;text&gt;|&lt;/text&gt;
@*
    }
*@
    &lt;a asp-action=&quot;Index&quot;&gt;Back to List&lt;/a&gt;
&lt;/div&gt;
</code></pre><h2 id="test-the-completed-app">Test the completed app</h2>
<p>If you are using Visual Studio Code or testing on local platform that doesn&#39;t include a test certificate for SSL:</p>
<ul>
<li>Set <code>&quot;LocalTest:skipSSL&quot;: true</code> in the <em>appsettings.json</em> file.</li>
</ul>
<p>If you have run the app and have contacts, delete all the records in the <code>Contact</code> table and restart the app to seed the database. If you are using Visual Studio, you need to exit and restart IIS Express to seed the database.</p>
<p>Register a user to browse the contacts.</p>
<p>An easy way to test the completed app is to launch three different browsers (or incognito/InPrivate versions). In one browser, register a new user, for example, <code>test@example.com</code>. Sign in to each browser with a different user. Verify the following:</p>
<ul>
<li>Registered users can view all the approved contact data.</li>
<li>Registered users can edit/delete their own data. </li>
<li>Managers can approve or reject contact data. The <code>Details</code> view shows <strong>Approve</strong> and <strong>Reject</strong> buttons. </li>
<li>Administrators can approve/reject and edit/delete any data.</li>
</ul>
<table>
<thead>
<tr>
<th>User</th>
<th>Options</th>
</tr>
</thead>
<tbody>
<tr>
<td>test@example.com</td>
<td>Can edit/delete own data</td>
</tr>
<tr>
<td>manager@contoso.com</td>
<td>Can approve/reject and edit/delete own data</td>
</tr>
<tr>
<td>admin@contoso.com</td>
<td>Can edit/delete and approve/reject all data</td>
</tr>
</tbody>
</table>
<p>Create a contact in the administrators browser. Copy the URL for delete and edit from the administrator contact. Paste these links into the test user&#39;s browser to verify the test user cannot perform these operations.</p>
<h2 id="create-the-starter-app">Create the starter app</h2>
<p>Follow these instructions to create the starter app.</p>
<ul>
<li><p>Create an <strong>ASP.NET Core Web Application</strong> using <a href="https://www.visualstudio.com/">Visual Studio 2017</a> named &quot;ContactManager&quot;</p>
<ul>
<li>Create the app with <strong>Individual User Accounts</strong>.</li>
<li>Name it &quot;ContactManager&quot; so your namespace will match the namespace use in the sample.</li>
</ul>
</li>
<li><p>Add the following <code>Contact</code> model:</p>
<pre><code class="lang-csharp" name="Main">public class Contact
{
    public int ContactId { get; set; }

    public string Name { get; set; }
    public string Address { get; set; }
    public string City { get; set; }
    public string State { get; set; }
    public string Zip { get; set; }
    public string Email { get; set; }
}
</code></pre></li>
<li><p>Scaffold the <code>Contact</code> model using Entity Framework Core and the <code>ApplicationDbContext</code> data context. Accept all the scaffolding defaults. Using <code>ApplicationDbContext</code> for the data context class  puts the contact table in the <a class="xref" href="../authentication/identity.html">Identity</a> database. See <a class="xref" href="../../tutorials/first-mvc-app/adding-model.html">Adding a model</a> for more information.</p>
</li>
<li><p>Update the <strong>ContactManager</strong> anchor in the <em>Views/Shared/_Layout.cshtml</em> file from <code>asp-controller=&quot;Home&quot;</code> to <code>asp-controller=&quot;Contacts&quot;</code> so tapping the <strong>ContactManager</strong> link will invoke the Contacts controller. The original markup:</p>
</li>
</ul>
<pre><code class="lang-html">   &lt;a asp-area=&quot;&quot; asp-controller=&quot;Home&quot; asp-action=&quot;Index&quot; class=&quot;navbar-brand&quot;&gt;ContactManager&lt;/a&gt;
</code></pre><p>The updated markup:</p>
<pre><code class="lang-html">   &lt;a asp-area=&quot;&quot; asp-controller=&quot;Contacts&quot; asp-action=&quot;Index&quot; class=&quot;navbar-brand&quot;&gt;ContactManager&lt;/a&gt;
</code></pre><ul>
<li>Scaffold the initial migration and update the database</li>
</ul>
<pre><code class="lang-none">   dotnet ef migrations add initial
   dotnet ef database update
</code></pre><ul>
<li>Test the app by creating, editing and deleting a contact</li>
</ul>
<h3 id="seed-the-database">Seed the database</h3>
<p>Add the <code>SeedData</code> class to the <em>Data</em> folder. If you&#39;ve downloaded the sample, you can copy the <em>SeedData.cs</em> file to the <em>Data</em> folder of the starter project.</p>
<pre><code class="lang-csharp" name="Main">
using ContactManager.Models;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Linq;
using System.Threading.Tasks;

namespace ContactManager.Data
{
    public static class SeedData
    {
        public static async Task Initialize(IServiceProvider serviceProvider, string testUserPw)
        {
            using (var context = new ApplicationDbContext(
                serviceProvider.GetRequiredService&lt;DbContextOptions&lt;ApplicationDbContext&gt;&gt;()))
            {
                var uid = await CreateTestUser(serviceProvider, testUserPw);
                SeedDB(context, uid);
            }
        }

        private static async Task&lt;string&gt; CreateTestUser(IServiceProvider serviceProvider, string testUserPw)
        {
            if (String.IsNullOrEmpty(testUserPw))
                return &quot;&quot;;

            const string SeedUserName = &quot;test@example.com&quot;;

            var userManager = serviceProvider.GetService&lt;UserManager&lt;ApplicationUser&gt;&gt;();

            var user = await userManager.FindByNameAsync(SeedUserName);
            if (user == null)
            {
                user = new ApplicationUser { UserName = SeedUserName };
                await userManager.CreateAsync(user, testUserPw);
            }

            return user.Id;
        }

        public static void SeedDB(ApplicationDbContext context, string uid)
        {
            if (context.Contact.Any())
            {
                return;   // DB has been seeded
            }

            context.Contact.AddRange(
                new Contact
                {
                    Name = &quot;Debra Garcia&quot;,
                    Address = &quot;1234 Main St&quot;,
                    City = &quot;Redmond&quot;,
                    State = &quot;WA&quot;,
                    Zip = &quot;10999&quot;,
                    Email = &quot;debra@example.com&quot;
                },
             new Contact
             {
                 Name = &quot;Thorsten Weinrich&quot;,
                 Address = &quot;5678 1st Ave W&quot;,
                 City = &quot;Redmond&quot;,
                 State = &quot;WA&quot;,
                 Zip = &quot;10999&quot;,
                 Email = &quot;thorsten@example.com&quot;
             },
             new Contact
             {
                 Name = &quot;Yuhong Li&quot;,
                 Address = &quot;9012 State st&quot;,
                 City = &quot;Redmond&quot;,
                 State = &quot;WA&quot;,
                 Zip = &quot;10999&quot;,
                 Email = &quot;yuhong@example.com&quot;
             },
             new Contact
             {
                 Name = &quot;Jon Orton&quot;,
                 Address = &quot;3456 Maple St&quot;,
                 City = &quot;Redmond&quot;,
                 State = &quot;WA&quot;,
                 Zip = &quot;10999&quot;,
                 Email = &quot;jon@example.com&quot;
             },
             new Contact
             {
                 Name = &quot;Diliana Alexieva-Bosseva&quot;,
                 Address = &quot;7890 2nd Ave E&quot;,
                 City = &quot;Redmond&quot;,
                 State = &quot;WA&quot;,
                 Zip = &quot;10999&quot;,
                 Email = &quot;diliana@example.com&quot;
             }
             );
            context.SaveChanges();
        }
    }
}
</code></pre><p>Add the highlighted code to the end of the <code>Configure</code> method in the <em>Startup.cs</em> file:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="28-">public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{
    loggerFactory.AddConsole(Configuration.GetSection(&quot;Logging&quot;));
    loggerFactory.AddDebug();

    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
        app.UseDatabaseErrorPage();
        app.UseBrowserLink();
    }
    else
    {
        app.UseExceptionHandler(&quot;/Home/Error&quot;);
    }

    app.UseStaticFiles();

    app.UseIdentity();

    app.UseMvc(routes =&gt;
    {
        routes.MapRoute(
            name: &quot;default&quot;,
            template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
    });

    try
    {
        SeedData.Initialize(app.ApplicationServices, &quot;&quot;).Wait();
    }
    catch
    {
        throw new System.Exception(&quot;You need to update the DB &quot;
            + &quot;\nPM &gt; Update-Database &quot; + &quot;\n or \n&quot; +
              &quot;&gt; dotnet ef database update&quot;
              + &quot;\nIf that doesn&#39;t work, comment out SeedData and register a new user&quot;);
    }
}
</code></pre><p>Test that the app seeded the database. The seed method does not run if there are any rows in the contact DB.</p>
<h3 id="create-a-class-used-in-the-tutorial">Create a class used in the tutorial</h3>
<ul>
<li>Create a folder named <em>Authorization</em>.</li>
<li>Copy the <em>Authorization\ContactOperations.cs</em> file from the completed project download, or copy the following code:</li>
</ul>
<pre><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Authorization.Infrastructure;

namespace ContactManager.Authorization
{
    public static class ContactOperations
    {
        public static OperationAuthorizationRequirement Create =   
          new OperationAuthorizationRequirement {Name=Constants.CreateOperationName};
        public static OperationAuthorizationRequirement Read = 
          new OperationAuthorizationRequirement {Name=Constants.ReadOperationName};  
        public static OperationAuthorizationRequirement Update = 
          new OperationAuthorizationRequirement {Name=Constants.UpdateOperationName}; 
        public static OperationAuthorizationRequirement Delete = 
          new OperationAuthorizationRequirement {Name=Constants.DeleteOperationName};
        public static OperationAuthorizationRequirement Approve = 
          new OperationAuthorizationRequirement {Name=Constants.ApproveOperationName};
        public static OperationAuthorizationRequirement Reject = 
          new OperationAuthorizationRequirement {Name=Constants.RejectOperationName};
    }

    public class Constants
    {
        public static readonly string CreateOperationName = &quot;Create&quot;;
        public static readonly string ReadOperationName = &quot;Read&quot;;
        public static readonly string UpdateOperationName = &quot;Update&quot;;
        public static readonly string DeleteOperationName = &quot;Delete&quot;;
        public static readonly string ApproveOperationName = &quot;Approve&quot;;
        public static readonly string RejectOperationName = &quot;Reject&quot;;

        public static readonly string ContactAdministratorsRole = 
                                                              &quot;ContactAdministrators&quot;;
        public static readonly string ContactManagersRole = &quot;ContactManagers&quot;;
    }
}
</code></pre><p><a name="secure-data-add-resources-label"></a></p>
<h3 id="additional-resources">Additional resources</h3>
<ul>
<li><a href="https://github.com/blowdart/AspNetAuthorizationWorkshop">ASP.NET Core Authorization Lab</a>. This lab goes into more detail on the security features introduced in this tutorial.</li>
<li><a href="index.html">Authorization in ASP.NET Core : Simple, role, claims-based and custom</a></li>
<li><a href="policies.html">Custom Policy-Based Authorization</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/aspnet/Docs/blob/w/riande/RP-EF/aspnetcore/security/authorization/secure-data.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2015-2017 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
