<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Creating Backend Services for Native Mobile Applications </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Creating Backend Services for Native Mobile Applications ">
    <meta name="generator" content="docfx 2.24.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="mobile/native-mobile-backend">
<h1 id="creating-backend-services-for-native-mobile-applications">Creating Backend Services for Native Mobile Applications</h1>

<p>By <a href="https://ardalis.com/">Steve Smith</a></p>
<p>Mobile apps can easily communicate with ASP.NET Core backend services.</p>
<p><a href="https://github.com/aspnet/Docs/tree/master/aspnetcore/mobile/native-mobile-backend/sample">View or download sample backend services code</a></p>
<h2 id="the-sample-native-mobile-app">The Sample Native Mobile App</h2>
<p>This tutorial demonstrates how to create backend services using ASP.NET Core MVC to support native mobile apps. It uses the <a href="https://developer.xamarin.com/guides/xamarin-forms/web-services/consuming/rest/">Xamarin Forms ToDoRest app</a> as its native client, which includes separate native clients for Android, iOS, Windows Universal, and Window Phone devices. You can follow the linked tutorial to create the native app (and install the necessary free Xamarin tools), as well as download the Xamarin sample solution. The Xamarin sample includes an ASP.NET Web API 2 services project, which this article&#39;s ASP.NET Core app replaces (with no changes required by the client).</p>
<p><img src="native-mobile-backend/_static/todo-android.png" alt="To Do Rest application running on an Android smartphone"></p>
<h3 id="features">Features</h3>
<p>The ToDoRest app supports listing, adding, deleting, and updating To-Do items. Each item has an ID, a Name, Notes, and a property indicating whether it&#39;s been Done yet.</p>
<p>The main view of the items, as shown above, lists each item&#39;s name and indicates if it is done with a checkmark.</p>
<p>Tapping the <code>+</code> icon opens an add item dialog:</p>
<p><img src="native-mobile-backend/_static/todo-android-new-item.png" alt="Add item dialog"></p>
<p>Tapping an item on the main list screen opens up an edit dialog where the item&#39;s Name, Notes, and Done settings can be modified, or the item can be deleted:</p>
<p><img src="native-mobile-backend/_static/todo-android-edit-item.png" alt="Edit item dialog"></p>
<p>This sample is configured by default to use backend services hosted at developer.xamarin.com, which allow read-only operations. To test it out yourself against the ASP.NET Core app created in the next section running on your computer, you&#39;ll need to update the app&#39;s <code>RestUrl</code> constant. Navigate to the <code>ToDoREST</code> project and open the <em>Constants.cs</em> file. Replace the <code>RestUrl</code> with a URL that includes your machine&#39;s IP address (not localhost or 127.0.0.1, since this address is used from the device emulator, not from your machine). Include the port number as well (5000). In order to test that your services work with a device, ensure you don&#39;t have an active firewall blocking access to this port.</p>
<!-- literal_block {"ids": [], "names": [], "highlight_args": {}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "csharp"} -->
<pre><code class="lang-csharp">// URL of REST service (Xamarin ReadOnly Service)
//public static string RestUrl = &quot;http://developer.xamarin.com:8081/api/todoitems{0}&quot;;

// use your machine&#39;s IP address
public static string RestUrl = &quot;http://192.168.1.207:5000/api/todoitems/{0}&quot;;
</code></pre><h2 id="creating-the-aspnet-core-project">Creating the ASP.NET Core Project</h2>
<p>Create a new ASP.NET Core Web Application in Visual Studio. Choose the Web API template and No Authentication. Name the project <em>ToDoApi</em>.</p>
<p><img src="native-mobile-backend/_static/web-api-template.png" alt="New ASP.NET Web Application dialog with Web API project template selected"></p>
<p>The application should respond to all requests made to port 5000. Update <em>Program.cs</em> to include <code>.UseUrls(&quot;http://*:5000&quot;)</code> to achieve this:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="3">var host = new WebHostBuilder()
    .UseKestrel()
    .UseUrls(&quot;http://*:5000&quot;)
    .UseContentRoot(Directory.GetCurrentDirectory())
    .UseIISIntegration()
    .UseStartup&lt;Startup&gt;()
    .Build();
</code></pre><div class="NOTE"><h5>Note</h5><p>Make sure you run the application directly, rather than behind IIS Express, which ignores non-local requests by default. Run <code>dotnet run</code> from a command prompt, or choose the application name profile from the Debug Target dropdown in the Visual Studio toolbar.</p>
</div>
<p>Add a model class to represent To-Do items. Mark required fields using the <code>[Required]</code> attribute:</p>
<pre><code class="lang-csharp" name="Main">using System.ComponentModel.DataAnnotations;

namespace ToDoApi.Models
{
    public class ToDoItem
    {
        [Required]
        public string ID { get; set; }

        [Required]
        public string Name { get; set; }

        [Required]
        public string Notes { get; set; }

        public bool Done { get; set; }
    }
}
</code></pre><p>The API methods require some way to work with data. Use the same <code>IToDoRepository</code> interface the original Xamarin sample uses:</p>
<pre><code class="lang-csharp" name="Main">using System.Collections.Generic;
using ToDoApi.Models;

namespace ToDoApi.Interfaces
{
    public interface IToDoRepository
    {
        bool DoesItemExist(string id);
        IEnumerable&lt;ToDoItem&gt; All { get; }
        ToDoItem Find(string id);
        void Insert(ToDoItem item);
        void Update(ToDoItem item);
        void Delete(string id);
    }
}
</code></pre><p>For this sample, the implementation just uses a private collection of items:</p>
<pre><code class="lang-csharp" name="Main">using System.Collections.Generic;
using System.Linq;
using ToDoApi.Interfaces;
using ToDoApi.Models;

namespace ToDoApi.Services
{
    public class ToDoRepository : IToDoRepository
    {
        private List&lt;ToDoItem&gt; _toDoList;

        public ToDoRepository()
        {
            InitializeData();
        }

        public IEnumerable&lt;ToDoItem&gt; All
        {
            get { return _toDoList; }
        }

        public bool DoesItemExist(string id)
        {
            return _toDoList.Any(item =&gt; item.ID == id);
        }

        public ToDoItem Find(string id)
        {
            return _toDoList.FirstOrDefault(item =&gt; item.ID == id);
        }

        public void Insert(ToDoItem item)
        {
            _toDoList.Add(item);
        }

        public void Update(ToDoItem item)
        {
            var todoItem = this.Find(item.ID);
            var index = _toDoList.IndexOf(todoItem);
            _toDoList.RemoveAt(index);
            _toDoList.Insert(index, item);
        }

        public void Delete(string id)
        {
            _toDoList.Remove(this.Find(id));
        }

        private void InitializeData()
        {
            _toDoList = new List&lt;ToDoItem&gt;();

            var todoItem1 = new ToDoItem
            {
                ID = &quot;6bb8a868-dba1-4f1a-93b7-24ebce87e243&quot;,
                Name = &quot;Learn app development&quot;,
                Notes = &quot;Attend Xamarin University&quot;,
                Done = true
            };

            var todoItem2 = new ToDoItem
            {
                ID = &quot;b94afb54-a1cb-4313-8af3-b7511551b33b&quot;,
                Name = &quot;Develop apps&quot;,
                Notes = &quot;Use Xamarin Studio/Visual Studio&quot;,
                Done = false
            };

            var todoItem3 = new ToDoItem
            {
                ID = &quot;ecfa6f80-3671-4911-aabe-63cc442c1ecf&quot;,
                Name = &quot;Publish apps&quot;,
                Notes = &quot;All app stores&quot;,
                Done = false,
            };

            _toDoList.Add(todoItem1);
            _toDoList.Add(todoItem2);
            _toDoList.Add(todoItem3);
        }
    }
}
</code></pre><p>Configure the implementation in <em>Startup.cs</em>:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="6">public void ConfigureServices(IServiceCollection services)
{
    // Add framework services.
    services.AddMvc();

    services.AddSingleton&lt;IToDoRepository,ToDoRepository&gt;();
}
</code></pre><p>At this point, you&#39;re ready to create the <em>ToDoItemsController</em>.</p>
<div class="TIP"><h5>Tip</h5><p>Learn more about creating web APIs in <a href="../tutorials/first-web-api.html">Building Your First Web API with ASP.NET Core MVC and Visual Studio</a>.</p>
</div>
<h2 id="creating-the-controller">Creating the Controller</h2>
<p>Add a new controller to the project, <em>ToDoItemsController</em>. It should inherit from Microsoft.AspNetCore.Mvc.Controller. Add a <code>Route</code> attribute to indicate that the controller will handle requests made to paths starting with <code>api/todoitems</code>. The <code>[controller]</code> token in the route is replaced by the name of the controller (omitting the <code>Controller</code> suffix), and is especially helpful for global routes. Learn more about <a href="../fundamentals/routing.html">routing</a>.</p>
<p>The controller requires an <code>IToDoRepository</code> to function; request an instance of this type through the controller&#39;s constructor. At runtime, this instance will be provided using the framework&#39;s support for <a href="../fundamentals/dependency-injection.html">dependency injection</a>.</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="9,14">using System;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using ToDoApi.Interfaces;
using ToDoApi.Models;

namespace ToDoApi.Controllers
{
    [Route(&quot;api/[controller]&quot;)]
    public class ToDoItemsController : Controller
    {
        private readonly IToDoRepository _toDoRepository;

        public ToDoItemsController(IToDoRepository toDoRepository)
        {
            _toDoRepository = toDoRepository;
        }
</code></pre><p>This API supports four different HTTP verbs to perform CRUD (Create, Read, Update, Delete) operations on the data source. The simplest of these is the Read operation, which corresponds to an HTTP GET request.</p>
<h3 id="reading-items">Reading Items</h3>
<p>Requesting a list of items is done with a GET request to the <code>List</code> method. The <code>[HttpGet]</code> attribute on the <code>List</code> method indicates that this action should only handle GET requests. The route for this action is the route specified on the controller. You don&#39;t necessarily need to use the action name as part of the route. You just need to ensure each action has a unique and unambiguous route. Routing attributes can be applied at both the controller and method levels to build up specific routes.</p>
<pre><code class="lang-csharp" name="Main">[HttpGet]
public IActionResult List()
{
    return Ok(_toDoRepository.All);
}
</code></pre><p>The <code>List</code> method returns a 200 OK response code and all of the ToDo items, serialized as JSON.</p>
<p>You can test your new API method using a variety of tools, such as <a href="https://www.getpostman.com/docs/">Postman</a>, shown here:</p>
<p><img src="native-mobile-backend/_static/postman-get.png" alt="Postman console showing a GET request for todoitems and the body of the response showing the JSON for three items returned"></p>
<h3 id="creating-items">Creating Items</h3>
<p>By convention, creating new data items is mapped to the HTTP POST verb. The <code>Create</code> method has an <code>[HttpPost]</code> attribute applied to it, and accepts a <code>ToDoItem</code> instance. Since the <code>item</code> argument will be passed in the body of the POST, this parameter is decorated with the <code>[FromBody]</code> attribute.</p>
<p>Inside the method, the item is checked for validity and prior existence in the data store, and if no issues occur, it is added using the repository. Checking <code>ModelState.IsValid</code> performs <a href="../mvc/models/validation.html">model validation</a>, and should be done in every API method that accepts user input.</p>
<pre><code class="lang-csharp" name="Main">[HttpPost]
public IActionResult Create([FromBody] ToDoItem item)
{
    try
    {
        if (item == null || !ModelState.IsValid)
        {
            return BadRequest(ErrorCode.TodoItemNameAndNotesRequired.ToString());
        }
        bool itemExists = _toDoRepository.DoesItemExist(item.ID);
        if (itemExists)
        {
            return StatusCode(StatusCodes.Status409Conflict, ErrorCode.TodoItemIDInUse.ToString());
        }
        _toDoRepository.Insert(item);
    }
    catch (Exception)
    {
        return BadRequest(ErrorCode.CouldNotCreateItem.ToString());
    }
    return Ok(item);
}
</code></pre><p>The sample uses an enum containing error codes that are passed to the mobile client:</p>
<pre><code class="lang-csharp" name="Main">public enum ErrorCode
{
    TodoItemNameAndNotesRequired,
    TodoItemIDInUse,
    RecordNotFound,
    CouldNotCreateItem,
    CouldNotUpdateItem,
    CouldNotDeleteItem
}
</code></pre><p>Test adding new items using Postman by choosing the POST verb providing the new object in JSON format in the Body of the request. You should also add a request header specifying a <code>Content-Type</code> of <code>application/json</code>.</p>
<p><img src="native-mobile-backend/_static/postman-post.png" alt="Postman console showing a POST and response"></p>
<p>The method returns the newly created item in the response.</p>
<h3 id="updating-items">Updating Items</h3>
<p>Modifying records is done using HTTP PUT requests. Other than this change, the <code>Edit</code> method is almost identical to <code>Create</code>. Note that if the record isn&#39;t found, the <code>Edit</code> action will return a <code>NotFound</code> (404) response.</p>
<pre><code class="lang-csharp" name="Main">[HttpPut]
public IActionResult Edit([FromBody] ToDoItem item)
{
    try
    {
        if (item == null || !ModelState.IsValid)
        {
            return BadRequest(ErrorCode.TodoItemNameAndNotesRequired.ToString());
        }
        var existingItem = _toDoRepository.Find(item.ID);
        if (existingItem == null)
        {
            return NotFound(ErrorCode.RecordNotFound.ToString());
        }
        _toDoRepository.Update(item);
    }
    catch (Exception)
    {
        return BadRequest(ErrorCode.CouldNotUpdateItem.ToString());
    }
    return NoContent();
}
</code></pre><p>To test with Postman, change the verb to PUT. Specify the updated object data in the Body of the request.</p>
<p><img src="native-mobile-backend/_static/postman-put.png" alt="Postman console showing a PUT and response"></p>
<p>This method returns a <code>NoContent</code> (204) response when successful, for consistency with the pre-existing API.</p>
<h3 id="deleting-items">Deleting Items</h3>
<p>Deleting records is accomplished by making DELETE requests to the service, and passing the ID of the item to be deleted. As with updates, requests for items that don&#39;t exist will receive <code>NotFound</code> responses. Otherwise, a successful request will get a <code>NoContent</code> (204) response.</p>
<pre><code class="lang-csharp" name="Main">[HttpDelete(&quot;{id}&quot;)]
public IActionResult Delete(string id)
{
    try
    {
        var item = _toDoRepository.Find(id);
        if (item == null)
        {
            return NotFound(ErrorCode.RecordNotFound.ToString());
        }
        _toDoRepository.Delete(id);
    }
    catch (Exception)
    {
        return BadRequest(ErrorCode.CouldNotDeleteItem.ToString());
    }
    return NoContent();
}
</code></pre><p>Note that when testing the delete functionality, nothing is required in the Body of the request.</p>
<p><img src="native-mobile-backend/_static/postman-delete.png" alt="Postman console showing a DELETE and response"></p>
<h2 id="common-web-api-conventions">Common Web API Conventions</h2>
<p>As you develop the backend services for your app, you will want to come up with a consistent set of conventions or policies for handling cross-cutting concerns. For example, in the service shown above, requests for specific records that weren&#39;t found received a <code>NotFound</code> response, rather than a <code>BadRequest</code> response. Similarly, commands made to this service that passed in model bound types always checked <code>ModelState.IsValid</code> and returned a <code>BadRequest</code> for invalid model types.</p>
<p>Once you&#39;ve identified a common policy for your APIs, you can usually encapsulate it in a <a href="../mvc/controllers/filters.html">filter</a>. Learn more about <a href="https://msdn.microsoft.com/magazine/mt767699.aspx">how to encapsulate common API policies in ASP.NET Core MVC applications</a>.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/aspnet/Docs/blob/w/riande/RP-EF/aspnetcore/mobile/native-mobile-backend.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2015-2017 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
