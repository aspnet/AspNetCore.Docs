<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Authoring Tag Helpers in ASP.NET Core </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Authoring Tag Helpers in ASP.NET Core ">
    <meta name="generator" content="docfx 2.24.0.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../../../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="mvc/views/tag-helpers/authoring">
<h1 id="authoring-tag-helpers-in-aspnet-core-a-walkthrough-with-samples">Authoring Tag Helpers in ASP.NET Core, a walkthrough with samples</h1>

<p>By <a href="https://twitter.com/RickAndMSFT">Rick Anderson</a></p>
<p><a href="https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/views/tag-helpers/authoring/sample">View or download sample code</a></p>
<h2 id="getting-started-with-tag-helpers">Getting started with Tag Helpers</h2>
<p>This tutorial provides an introduction to programming Tag Helpers. <a href="intro.html">Introduction to Tag Helpers</a> describes the benefits that Tag Helpers provide.</p>
<p>A tag helper is any class that implements the <code>ITagHelper</code> interface. However, when you author a tag helper, you generally derive from <code>TagHelper</code>, doing so gives you access to the <code>Process</code> method.</p>
<ol>
<li><p>Create a new ASP.NET Core project called <strong>AuthoringTagHelpers</strong>. You won&#39;t need authentication for this project.</p>
</li>
<li><p>Create a folder to hold the Tag Helpers called <em>TagHelpers</em>. The <em>TagHelpers</em> folder is <em>not</em> required, but it is a reasonable convention. Now let&#39;s get started writing some simple tag helpers.</p>
</li>
</ol>
<h2 id="a-minimal-tag-helper">A minimal Tag Helper</h2>
<p>In this section, you write a tag helper that updates an email tag. For example:</p>
<pre><code class="lang-html">&lt;email&gt;Support&lt;/email&gt;
</code></pre><p>The server will use our email tag helper to convert that markup into the following:</p>
<pre><code class="lang-html">&lt;a href=&quot;mailto:Support@contoso.com&quot;&gt;Support@contoso.com&lt;/a&gt;
</code></pre><p>That is, an anchor tag that makes this an email link. You might want to do this if you are writing a blog engine and need it to send email for marketing, support, and other contacts, all to the same domain.</p>
<ol>
<li><p>Add the following <code>EmailTagHelper</code> class to the <em>TagHelpers</em> folder.</p>
<pre><code class="lang-csharp" name="Main">
using Microsoft.AspNetCore.Razor.TagHelpers;
using System.Threading.Tasks;

namespace AuthoringTagHelpers.TagHelpers
{
    public class EmailTagHelper : TagHelper
    {
        public override void Process(TagHelperContext context, TagHelperOutput output)
        {
            output.TagName = &quot;a&quot;;    // Replaces &lt;email&gt; with &lt;a&gt; tag
        }
    }
}
</code></pre><p><strong>Notes:</strong></p>
<ul>
<li><p>Tag helpers use a naming convention that targets elements of the root class name (minus the <em>TagHelper</em> portion of the class name). In this example, the root name of <strong>Email</strong>TagHelper is <em>email</em>, so the <code>&lt;email&gt;</code> tag will be targeted. This naming convention should work for most tag helpers, later on I&#39;ll show how to override it.</p>
</li>
<li><p>The <code>EmailTagHelper</code> class derives from <code>TagHelper</code>. The <code>TagHelper</code> class provides methods and properties for writing Tag Helpers.</p>
</li>
<li><p>The  overridden <code>Process</code> method controls what the tag helper does when executed. The <code>TagHelper</code> class also provides an asynchronous version (<code>ProcessAsync</code>) with the same parameters.</p>
</li>
<li><p>The context parameter to <code>Process</code> (and <code>ProcessAsync</code>) contains information associated with the execution of the current HTML tag.</p>
</li>
<li><p>The output parameter to <code>Process</code> (and <code>ProcessAsync</code>) contains a stateful HTML element representative of the original source used to generate an HTML tag and content.</p>
</li>
<li><p>Our class name has a suffix of <strong>TagHelper</strong>, which is <em>not</em> required, but it&#39;s considered a best practice convention. You could declare the class as:</p>
</li>
</ul>
<pre><code class="lang-csharp">public class Email : TagHelper
</code></pre></li>
<li><p>To make the <code>EmailTagHelper</code> class available to all our Razor views, add the <code>addTagHelper</code> directive to the <em>Views/_ViewImports.cshtml</em> file:</p>
<pre><code class="lang-html" name="Main" highlight-lines="2,3">@using AuthoringTagHelpers
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
@addTagHelper *, AuthoringTagHelpers
</code></pre><p>The code above uses the wildcard syntax to specify all the tag helpers in our assembly will be available. The first string after <code>@addTagHelper</code> specifies the tag helper to load (Use &quot;*&quot; for all tag helpers), and the second string &quot;AuthoringTagHelpers&quot; specifies the assembly the tag helper is in. Also, note that the second line brings in the ASP.NET Core MVC tag helpers using the wildcard syntax (those helpers are discussed in <a href="intro.html">Introduction to Tag Helpers</a>.) It&#39;s the <code>@addTagHelper</code> directive that makes the tag helper available to the Razor view. Alternatively, you can provide the fully qualified name (FQN) of a tag helper as shown below:</p>
<pre><code class="lang-html" name="Main" highlight-lines="3">@using AuthoringTagHelpers
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
@addTagHelper AuthoringTagHelpers.TagHelpers3.EmailTagHelper, AuthoringTagHelpers
</code></pre><p>To add a tag helper to a view using a FQN, you first add the FQN (<code>AuthoringTagHelpers.TagHelpers.EmailTagHelper</code>), and then the assembly name (<em>AuthoringTagHelpers</em>). Most developers will prefer to use the wildcard syntax. <a href="intro.html">Introduction to Tag Helpers</a> goes into detail on tag helper adding, removing, hierarchy, and wildcard syntax.</p>
</li>
<li><p>Update the markup in the <em>Views/Home/Contact.cshtml</em> file with these changes:</p>
<pre><code class="lang-html" name="Main" highlight-lines="15,16">@{
    ViewData[&quot;Title&quot;] = &quot;Contact&quot;;
}
&lt;h2&gt;@ViewData[&quot;Title&quot;].&lt;/h2&gt;
&lt;h3&gt;@ViewData[&quot;Message&quot;]&lt;/h3&gt;

&lt;address&gt;
    One Microsoft Way&lt;br /&gt;
    Redmond, WA 98052&lt;br /&gt;
    &lt;abbr title=&quot;Phone&quot;&gt;P:&lt;/abbr&gt;
    425.555.0100
&lt;/address&gt;

&lt;address&gt;
    &lt;strong&gt;Support:&lt;/strong&gt;&lt;email&gt;Support&lt;/email&gt;&lt;br /&gt;
    &lt;strong&gt;Marketing:&lt;/strong&gt;&lt;email&gt;Marketing&lt;/email&gt;
&lt;/address&gt;
</code></pre></li>
<li><p>Run the app and use your favorite browser to view the HTML source so you can verify that the email tags are replaced with anchor markup (For example, <code>&lt;a&gt;Support&lt;/a&gt;</code>). <em>Support</em> and <em>Marketing</em> are rendered as a links, but they don&#39;t have an <code>href</code> attribute to make them functional. We&#39;ll fix that in the next section.</p>
</li>
</ol>
<p>Note: Like HTML tags and attributes, tags, class names and attributes in Razor, and C# are not case-sensitive.</p>
<h2 id="setattribute-and-setcontent">SetAttribute and SetContent</h2>
<p>In this section, we&#39;ll update the <code>EmailTagHelper</code> so that it will create a valid anchor tag for email. We&#39;ll update it to take information from a Razor view (in the form of a <code>mail-to</code> attribute) and use that in generating the anchor.</p>
<p>Update the <code>EmailTagHelper</code> class with the following:</p>
<pre><code class="lang-csharp" name="Main">public class EmailTagHelper : TagHelper
{
    private const string EmailDomain = &quot;contoso.com&quot;;

    // Can be passed via &lt;email mail-to=&quot;...&quot; /&gt;. 
    // Pascal case gets translated into lower-kebab-case.
    public string MailTo { get; set; }

    public override void Process(TagHelperContext context, TagHelperOutput output)
    {
        output.TagName = &quot;a&quot;;    // Replaces &lt;email&gt; with &lt;a&gt; tag

        var address = MailTo + &quot;@&quot; + EmailDomain;
        output.Attributes.SetAttribute(&quot;href&quot;, &quot;mailto:&quot; + address);
        output.Content.SetContent(address);
    }
}
</code></pre><p><strong>Notes:</strong></p>
<ul>
<li><p>Pascal-cased class and property names for tag helpers are translated into their <a href="https://stackoverflow.com/questions/11273282/whats-the-name-for-dash-separated-case/12273101">lower kebab case</a>. Therefore, to use the <code>MailTo</code> attribute, you&#39;ll use <code>&lt;email mail-to=&quot;value&quot;/&gt;</code> equivalent.</p>
</li>
<li><p>The last line sets the completed content for our minimally functional tag helper.</p>
</li>
<li><p>The highlighted line shows the syntax for adding attributes:</p>
</li>
</ul>
<pre><code class="lang-csharp" name="Main" highlight-lines="6">public override void Process(TagHelperContext context, TagHelperOutput output)
{
    output.TagName = &quot;a&quot;;    // Replaces &lt;email&gt; with &lt;a&gt; tag

    var address = MailTo + &quot;@&quot; + EmailDomain;
    output.Attributes.SetAttribute(&quot;href&quot;, &quot;mailto:&quot; + address);
    output.Content.SetContent(address);
}
</code></pre><p>That approach works for the attribute &quot;href&quot; as long as it doesn&#39;t currently exist in the attributes collection. You can also use the <code>output.Attributes.Add</code> method to add a tag helper attribute to the end of the collection of tag attributes.</p>
<ol>
<li><p>Update the markup in the <em>Views/Home/Contact.cshtml</em> file with these changes:</p>
<pre><code class="lang-html" name="Main" highlight-lines="15,16">@{
    ViewData[&quot;Title&quot;] = &quot;Contact Copy&quot;;
}
&lt;h2&gt;@ViewData[&quot;Title&quot;].&lt;/h2&gt;
&lt;h3&gt;@ViewData[&quot;Message&quot;]&lt;/h3&gt;

&lt;address&gt;
    One Microsoft Way Copy Version &lt;br /&gt;
    Redmond, WA 98052-6399&lt;br /&gt;
    &lt;abbr title=&quot;Phone&quot;&gt;P:&lt;/abbr&gt;
    425.555.0100
&lt;/address&gt;

&lt;address&gt;
    &lt;strong&gt;Support:&lt;/strong&gt;&lt;email mail-to=&quot;Support&quot;&gt;&lt;/email&gt;&lt;br /&gt;
    &lt;strong&gt;Marketing:&lt;/strong&gt;&lt;email mail-to=&quot;Marketing&quot;&gt;&lt;/email&gt;
&lt;/address&gt;
</code></pre></li>
<li><p>Run the app and verify that it generates the correct links.</p>
<div class="NOTE"><h5>Note</h5><p>If you were to write the email tag self-closing (<code>&lt;email mail-to=&quot;Rick&quot; /&gt;</code>), the final output would also be self-closing. To enable the ability to write the tag with only a start tag (<code>&lt;email mail-to=&quot;Rick&quot;&gt;</code>) you must decorate the class with the following:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="1">[HtmlTargetElement(&quot;email&quot;, TagStructure = TagStructure.WithoutEndTag)] 
public class EmailVoidTagHelper : TagHelper
{
    private const string EmailDomain = &quot;contoso.com&quot;;
    // Code removed for brevity
</code></pre></div>
<p>With a self-closing email tag helper, the output would be <code>&lt;a href=&quot;mailto:Rick@contoso.com&quot; /&gt;</code>. Self-closing anchor tags are not valid HTML, so you wouldn&#39;t want to create one, but you might want to create a tag helper that is self-closing. Tag helpers set the type of the <code>TagMode</code> property after reading a tag.</p>
</li>
</ol>
<h3 id="processasync">ProcessAsync</h3>
<p>In this section, we&#39;ll write an asynchronous email helper.</p>
<ol>
<li><p>Replace the <code>EmailTagHelper</code> class with the following code:</p>
<pre><code class="lang-csharp" name="Main">public class EmailTagHelper : TagHelper
{
    private const string EmailDomain = &quot;contoso.com&quot;;
    public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
    {
        output.TagName = &quot;a&quot;;                                 // Replaces &lt;email&gt; with &lt;a&gt; tag
        var content = await output.GetChildContentAsync();
        var target = content.GetContent() + &quot;@&quot; + EmailDomain;
        output.Attributes.SetAttribute(&quot;href&quot;, &quot;mailto:&quot; + target);
        output.Content.SetContent(target);
    }
}
</code></pre><p><strong>Notes:</strong></p>
<ul>
<li><p>This version uses the asynchronous <code>ProcessAsync</code> method. The asynchronous <code>GetChildContentAsync</code> returns a <code>Task</code> containing the <code>TagHelperContent</code>.</p>
</li>
<li><p>Use the <code>output</code> parameter to get contents of the HTML element.</p>
</li>
</ul>
</li>
<li><p>Make the following change to the <em>Views/Home/Contact.cshtml</em> file so the tag helper can get the target email.</p>
<pre><code class="lang-html" name="Main" highlight-lines="15,16">@{
    ViewData[&quot;Title&quot;] = &quot;Contact&quot;;
}
&lt;h2&gt;@ViewData[&quot;Title&quot;].&lt;/h2&gt;
&lt;h3&gt;@ViewData[&quot;Message&quot;]&lt;/h3&gt;

&lt;address&gt;
    One Microsoft Way&lt;br /&gt;
    Redmond, WA 98052&lt;br /&gt;
    &lt;abbr title=&quot;Phone&quot;&gt;P:&lt;/abbr&gt;
    425.555.0100
&lt;/address&gt;

&lt;address&gt;
    &lt;strong&gt;Support:&lt;/strong&gt;&lt;email&gt;Support&lt;/email&gt;&lt;br /&gt;
    &lt;strong&gt;Marketing:&lt;/strong&gt;&lt;email&gt;Marketing&lt;/email&gt;
&lt;/address&gt;
</code></pre></li>
<li><p>Run the app and verify that it generates valid email links.</p>
</li>
</ol>
<h3 id="removeall-precontentsethtmlcontent-and-postcontentsethtmlcontent">RemoveAll, PreContent.SetHtmlContent and PostContent.SetHtmlContent</h3>
<ol>
<li><p>Add the following <code>BoldTagHelper</code> class to the <em>TagHelpers</em> folder.</p>
<pre><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Razor.TagHelpers;

namespace AuthoringTagHelpers.TagHelpers
{
    [HtmlTargetElement(Attributes = &quot;bold&quot;)]
    public class BoldTagHelper : TagHelper
    {
        public override void Process(TagHelperContext context, TagHelperOutput output)
        {
            output.Attributes.RemoveAll(&quot;bold&quot;);
            output.PreContent.SetHtmlContent(&quot;&lt;strong&gt;&quot;);
            output.PostContent.SetHtmlContent(&quot;&lt;/strong&gt;&quot;);
        }
    }
}
</code></pre><p><strong>Notes:</strong></p>
<ul>
<li><p>The <code>[HtmlTargetElement]</code> attribute passes an attribute parameter that specifies that any HTML element that contains an HTML attribute named &quot;bold&quot; will match, and the <code>Process</code> override method in the class will run. In our sample, the <code>Process</code>  method removes the &quot;bold&quot; attribute and surrounds the containing markup with <code>&lt;strong&gt;&lt;/strong&gt;</code>.</p>
</li>
<li><p>Because you don&#39;t want to replace the existing tag content, you must write the opening <code>&lt;strong&gt;</code> tag with the <code>PreContent.SetHtmlContent</code> method and the closing <code>&lt;/strong&gt;</code> tag with the <code>PostContent.SetHtmlContent</code> method.</p>
</li>
</ul>
</li>
<li><p>Modify the <em>About.cshtml</em> view to contain a <code>bold</code> attribute value. The completed code is shown below.</p>
<pre><code class="lang-html" name="Main" highlight-lines="7">@{
    ViewData[&quot;Title&quot;] = &quot;About&quot;;
}
&lt;h2&gt;@ViewData[&quot;Title&quot;].&lt;/h2&gt;
&lt;h3&gt;@ViewData[&quot;Message&quot;]&lt;/h3&gt;

&lt;p bold&gt;Use this area to provide additional information.&lt;/p&gt;

&lt;bold&gt; Is this bold?&lt;/bold&gt;
</code></pre></li>
<li><p>Run the app. You can use your favorite browser to inspect the source and verify the markup.</p>
<p>The <code>[HtmlTargetElement]</code> attribute above only targets HTML markup that provides an attribute name of &quot;bold&quot;. The <code>&lt;bold&gt;</code> element was not modified by the tag helper.</p>
</li>
<li><p>Comment out the <code>[HtmlTargetElement]</code> attribute line and it will default to targeting <code>&lt;bold&gt;</code> tags, that is, HTML markup of the form <code>&lt;bold&gt;</code>. Remember, the default naming convention will match the class name <strong>Bold</strong>TagHelper to <code>&lt;bold&gt;</code> tags.</p>
</li>
<li><p>Run the app and verify that the <code>&lt;bold&gt;</code> tag is processed by the tag helper.</p>
</li>
</ol>
<p>Decorating a class with multiple <code>[HtmlTargetElement]</code> attributes results in a logical-OR of the targets. For example, using the code below, a bold tag or a bold attribute will match.</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="1,2">[HtmlTargetElement(&quot;bold&quot;)]
[HtmlTargetElement(Attributes = &quot;bold&quot;)]
public class BoldTagHelper : TagHelper
{
    public override void Process(TagHelperContext context, TagHelperOutput output)
    {
        output.Attributes.RemoveAll(&quot;bold&quot;);
        output.PreContent.SetHtmlContent(&quot;&lt;strong&gt;&quot;);
        output.PostContent.SetHtmlContent(&quot;&lt;/strong&gt;&quot;);
    }
}
</code></pre><p>When multiple attributes are added to the same statement, the runtime treats them as a logical-AND. For example, in the code below, an HTML element must be named &quot;bold&quot; with an attribute named &quot;bold&quot; (<code>&lt;bold bold /&gt;</code>) to match.</p>
<pre><code class="lang-csharp">[HtmlTargetElement(&quot;bold&quot;, Attributes = &quot;bold&quot;)]
</code></pre><p>You can also use the <code>[HtmlTargetElement]</code> to change the name of the targeted element. For example if you wanted the <code>BoldTagHelper</code> to target <code>&lt;MyBold&gt;</code> tags, you would use the following attribute:</p>
<pre><code class="lang-csharp">[HtmlTargetElement(&quot;MyBold&quot;)]
</code></pre><h2 id="passing-a-model-to-a-tag-helper">Passing a model to a Tag Helper</h2>
<ol>
<li><p>Add a <em>Models</em> folder.</p>
</li>
<li><p>Add the following <code>WebsiteContext</code> class to the <em>Models</em> folder:</p>
<pre><code class="lang-csharp" name="Main">using System;

namespace AuthoringTagHelpers.Models
{
    public class WebsiteContext
    {
        public Version Version { get; set; }
        public int CopyrightYear { get; set; }
        public bool Approved { get; set; }
        public int TagsToShow { get; set; }
    }
}
</code></pre></li>
<li><p>Add the following <code>WebsiteInformationTagHelper</code> class to the <em>TagHelpers</em> folder.</p>
<pre><code class="lang-csharp" name="Main">using System;
using AuthoringTagHelpers.Models;
using Microsoft.AspNetCore.Razor.TagHelpers;

namespace AuthoringTagHelpers.TagHelpers
{
    public class WebsiteInformationTagHelper : TagHelper
    {
        public WebsiteContext Info { get; set; }

      public override void Process(TagHelperContext context, TagHelperOutput output)
      {
         output.TagName = &quot;section&quot;;
         output.Content.SetHtmlContent(
$@&quot;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Version:&lt;/strong&gt; {Info.Version}&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Copyright Year:&lt;/strong&gt; {Info.CopyrightYear}&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Approved:&lt;/strong&gt; {Info.Approved}&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Number of tags to show:&lt;/strong&gt; {Info.TagsToShow}&lt;/li&gt;&lt;/ul&gt;&quot;);
         output.TagMode = TagMode.StartTagAndEndTag;
      }
   }
}
</code></pre><p><strong>Notes:</strong></p>
<ul>
<li><p>As mentioned previously, tag helpers translates Pascal-cased C# class names and properties for tag helpers into <a href="http://wiki.c2.com/?KebabCase">lower kebab case</a>. Therefore, to use the <code>WebsiteInformationTagHelper</code> in Razor, you&#39;ll write <code>&lt;website-information /&gt;</code>.</p>
</li>
<li><p>You are not explicitly identifying the target element with the <code>[HtmlTargetElement]</code> attribute, so the default of <code>website-information</code> will be targeted. If you applied the following attribute (note it&#39;s not kebab case but matches the class name):</p>
</li>
</ul>
<pre><code class="lang-csharp">[HtmlTargetElement(&quot;WebsiteInformation&quot;)]
</code></pre><p>The lower kebab case tag <code>&lt;website-information /&gt;</code> would not match. If you want use the <code>[HtmlTargetElement]</code> attribute, you would use kebab case as shown below:</p>
<pre><code class="lang-csharp">[HtmlTargetElement(&quot;Website-Information&quot;)]
</code></pre><ul>
<li><p>Elements that are self-closing have no content. For this example, the Razor markup will use a self-closing tag, but the tag helper will be creating a <a href="http://www.w3.org/TR/html5/sections.html#the-section-element">section</a> element (which is not self-closing and you are writing content inside the <code>section</code> element). Therefore, you need to set <code>TagMode</code> to <code>StartTagAndEndTag</code> to write output. Alternatively, you can comment out the line setting <code>TagMode</code> and write markup with a closing tag. (Example markup is provided later in this tutorial.)</p>
</li>
<li><p>The <code>$</code> (dollar sign) in the following line uses an <a href="https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/interpolated-strings">interpolated string</a>:</p>
</li>
</ul>
<pre><code class="lang-cshtml">$@&quot;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Version:&lt;/strong&gt; {Info.Version}&lt;/li&gt;
</code></pre></li>
<li><p>Add the following markup to the <em>About.cshtml</em> view. The highlighted markup displays the web site information.</p>
<pre><code class="lang-html" name="Main" highlight-lines="1,12-">@using AuthoringTagHelpers.Models
@{
    ViewData[&quot;Title&quot;] = &quot;About&quot;;
}
&lt;h2&gt;@ViewData[&quot;Title&quot;].&lt;/h2&gt;
&lt;h3&gt;@ViewData[&quot;Message&quot;]&lt;/h3&gt;

&lt;p bold&gt;Use this area to provide additional information.&lt;/p&gt;

&lt;bold&gt; Is this bold?&lt;/bold&gt;

&lt;h3&gt; web site info &lt;/h3&gt;
&lt;website-information info=&quot;new WebsiteContext {
                                    Version = new Version(1, 3),
                                    CopyrightYear = 1638,
                                    Approved = true,
                                    TagsToShow = 131 }&quot; /&gt;
</code></pre><div class="NOTE"><h5>Note</h5><p>In the Razor markup shown below:</p>
<pre><code class="lang-html" name="Main">&lt;website-information info=&quot;new WebsiteContext {
                                    Version = new Version(1, 3),
                                    CopyrightYear = 1638,
                                    Approved = true,
                                    TagsToShow = 131 }&quot; /&gt;
</code></pre><p>Razor knows the <code>info</code> attribute is a class, not a string, and you want to write C# code. Any non-string tag helper attribute should be written without the <code>@</code> character.</p>
</div>
</li>
<li><p>Run the app, and navigate to the About view to see the web site information.</p>
<div class="NOTE"><h5>Note</h5><p>You can use the following markup with a closing tag and remove the line with <code>TagMode.StartTagAndEndTag</code> in the tag helper:</p>
<pre><code class="lang-html" name="Main">&lt;website-information info=&quot;new WebsiteContext {
                                    Version = new Version(1, 3),
                                    CopyrightYear = 1638,
                                    Approved = true,
                                    TagsToShow = 131 }&quot; &gt;
&lt;/website-information&gt;
</code></pre></div>
</li>
</ol>
<h2 id="condition-tag-helper">Condition Tag Helper</h2>
<p>The condition tag helper renders output when passed a true value.</p>
<ol>
<li><p>Add the following <code>ConditionTagHelper</code> class to the <em>TagHelpers</em> folder.</p>
<pre><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Razor.TagHelpers;

namespace AuthoringTagHelpers.TagHelpers
{
    [HtmlTargetElement(Attributes = nameof(Condition))]
    public class ConditionTagHelper : TagHelper
    {
        public bool Condition { get; set; }

        public override void Process(TagHelperContext context, TagHelperOutput output)
        {
            if (!Condition)
            {
                output.SuppressOutput();
            }
        }
    }
}
</code></pre></li>
<li><p>Replace the contents of the <em>Views/Home/Index.cshtml</em> file with the following markup:</p>
<!-- literal_block {"xml:space": "preserve", "source": "mvc/views/tag-helpers/authoring/sample/AuthoringTagHelpers/src/AuthoringTagHelpers/Views/Home/Index.cshtml", "ids": [], "linenos": false, "highlight_args": {"linenostart": 1}} -->
<pre><code class="lang-cshtml">@using AuthoringTagHelpers.Models
@model WebsiteContext

@{
    ViewData[&quot;Title&quot;] = &quot;Home Page&quot;;
}

&lt;div&gt;
    &lt;h3&gt;Information about our website (outdated):&lt;/h3&gt;
    &lt;website-information info=Model /&gt;
    &lt;div condition=&quot;Model.Approved&quot;&gt;
        &lt;p&gt;
            This website has &lt;strong surround=&quot;em&quot;&gt; @Model.Approved &lt;/strong&gt; been approved yet.
            Visit www.contoso.com for more information.
        &lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre></li>
<li><p>Replace the <code>Index</code> method in the <code>Home</code> controller with the following code:</p>
<pre><code class="lang-csharp" name="Main">public IActionResult Index(bool approved = false)
{
    return View(new WebsiteContext
    {
        Approved = approved,
        CopyrightYear = 2015,
        Version = new Version(1, 3, 3, 7),
        TagsToShow = 20
    });
}
</code></pre></li>
<li><p>Run the app and browse to the home page. The markup in the conditional <code>div</code> will not be rendered. Append the query string <code>?approved=true</code> to the URL (for example, <code>http://localhost:1235/Home/Index?approved=true</code>). <code>approved</code> is set to true and the conditional markup will be displayed.</p>
</li>
</ol>
<div class="NOTE"><h5>Note</h5><p>Use the <a href="https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/nameof">nameof</a> operator to specify the attribute to target rather than specifying a string as you did with the bold tag helper:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="1,2,5">[HtmlTargetElement(Attributes = nameof(Condition))]
 //   [HtmlTargetElement(Attributes = &quot;condition&quot;)]
 public class ConditionTagHelper : TagHelper
{
   public bool Condition { get; set; }

   public override void Process(TagHelperContext context, TagHelperOutput output)
   {
      if (!Condition)
      {
         output.SuppressOutput();
      }
   }
}
</code></pre><p>The <a href="https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/nameof">nameof</a> operator will protect the code should it ever be refactored (we might want to change the name to <code>RedCondition</code>).</p>
</div>
<h3 id="avoiding-tag-helper-conflicts">Avoiding Tag Helper conflicts</h3>
<p>In this section, you write a pair of auto-linking tag helpers. The first will replace markup containing a URL starting with HTTP to an HTML anchor tag containing the same URL (and thus yielding a link to the URL). The second will do the same for a URL starting with WWW.</p>
<p>Because these two helpers are closely related and you may refactor them in the future, we&#39;ll keep them in the same file.</p>
<ol>
<li><p>Add the following <code>AutoLinkerHttpTagHelper</code> class to the <em>TagHelpers</em> folder.</p>
<pre><code class="lang-csharp" name="Main">[HtmlTargetElement(&quot;p&quot;)]
public class AutoLinkerHttpTagHelper : TagHelper
{
    public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
    {
        var childContent = await output.GetChildContentAsync();
        // Find Urls in the content and replace them with their anchor tag equivalent.
        output.Content.SetHtmlContent(Regex.Replace(
             childContent.GetContent(),
             @&quot;\b(?:https?://)(\S+)\b&quot;,
              &quot;&lt;a target=\&quot;_blank\&quot; href=\&quot;$0\&quot;&gt;$0&lt;/a&gt;&quot;));  // http link version}
    }
}
</code></pre><div class="NOTE"><h5>Note</h5><p>The <code>AutoLinkerHttpTagHelper</code> class targets <code>p</code> elements and uses <a href="https://docs.microsoft.com/dotnet/standard/base-types/regular-expression-language-quick-reference">Regex</a> to create the anchor.</p>
</div>
</li>
<li><p>Add the following markup to the end of the <em>Views/Home/Contact.cshtml</em> file:</p>
<pre><code class="lang-html" name="Main" highlight-lines="19">@{
    ViewData[&quot;Title&quot;] = &quot;Contact&quot;;
}
&lt;h2&gt;@ViewData[&quot;Title&quot;].&lt;/h2&gt;
&lt;h3&gt;@ViewData[&quot;Message&quot;]&lt;/h3&gt;

&lt;address&gt;
    One Microsoft Way&lt;br /&gt;
    Redmond, WA 98052&lt;br /&gt;
    &lt;abbr title=&quot;Phone&quot;&gt;P:&lt;/abbr&gt;
    425.555.0100
&lt;/address&gt;

&lt;address&gt;
    &lt;strong&gt;Support:&lt;/strong&gt;&lt;email&gt;Support&lt;/email&gt;&lt;br /&gt;
    &lt;strong&gt;Marketing:&lt;/strong&gt;&lt;email&gt;Marketing&lt;/email&gt;
&lt;/address&gt;

&lt;p&gt;Visit us at http://docs.asp.net or at www.microsoft.com&lt;/p&gt;
</code></pre></li>
<li><p>Run the app and verify that the tag helper renders the anchor correctly.</p>
</li>
<li><p>Update the <code>AutoLinker</code> class to include the <code>AutoLinkerWwwTagHelper</code> which will convert www text to an anchor tag that also contains the original www text. The updated code is highlighted below:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="15-34">    [HtmlTargetElement(&quot;p&quot;)]
    public class AutoLinkerHttpTagHelper : TagHelper
    {
        public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
        {
            var childContent = await output.GetChildContentAsync();
            // Find Urls in the content and replace them with their anchor tag equivalent.
            output.Content.SetHtmlContent(Regex.Replace(
                 childContent.GetContent(),
                 @&quot;\b(?:https?://)(\S+)\b&quot;,
                  &quot;&lt;a target=\&quot;_blank\&quot; href=\&quot;$0\&quot;&gt;$0&lt;/a&gt;&quot;));  // http link version}
        }
    }

    [HtmlTargetElement(&quot;p&quot;)]
    public class AutoLinkerWwwTagHelper : TagHelper
    {
        public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
        {
            var childContent = await output.GetChildContentAsync();
            // Find Urls in the content and replace them with their anchor tag equivalent.
            output.Content.SetHtmlContent(Regex.Replace(
                childContent.GetContent(),
                 @&quot;\b(www\.)(\S+)\b&quot;,
                 &quot;&lt;a target=\&quot;_blank\&quot; href=\&quot;http://$0\&quot;&gt;$0&lt;/a&gt;&quot;));  // www version
        }
    }
}
</code></pre></li>
<li><p>Run the app. Notice the www text is rendered as a link but the HTTP text is not. If you put a break point in both classes, you can see that the HTTP tag helper class runs first. The problem is that the tag helper output is cached, and when the WWW tag helper is run, it overwrites the cached output from the HTTP tag helper. Later in the tutorial we&#39;ll see how to control the order that tag helpers run in. We&#39;ll fix the code with the following:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="5,6,10,21,22,26">public class AutoLinkerHttpTagHelper : TagHelper
{
    public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
    {
        var childContent = output.Content.IsModified ? output.Content.GetContent() :
            (await output.GetChildContentAsync()).GetContent();

        // Find Urls in the content and replace them with their anchor tag equivalent.
        output.Content.SetHtmlContent(Regex.Replace(
             childContent,
             @&quot;\b(?:https?://)(\S+)\b&quot;,
              &quot;&lt;a target=\&quot;_blank\&quot; href=\&quot;$0\&quot;&gt;$0&lt;/a&gt;&quot;));  // http link version}
    }
}

[HtmlTargetElement(&quot;p&quot;)]
public class AutoLinkerWwwTagHelper : TagHelper
{
    public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
    {
        var childContent = output.Content.IsModified ? output.Content.GetContent() : 
            (await output.GetChildContentAsync()).GetContent();

        // Find Urls in the content and replace them with their anchor tag equivalent.
        output.Content.SetHtmlContent(Regex.Replace(
             childContent,
             @&quot;\b(www\.)(\S+)\b&quot;,
             &quot;&lt;a target=\&quot;_blank\&quot; href=\&quot;http://$0\&quot;&gt;$0&lt;/a&gt;&quot;));  // www version
    }
}
</code></pre><div class="NOTE"><h5>Note</h5><p>In the first edition of the auto-linking tag helpers, you got the content of the target with the following code:</p>
<pre><code class="lang-csharp" name="Main">var childContent = await output.GetChildContentAsync();
</code></pre><p>That is, you call <code>GetChildContentAsync</code> using the <code>TagHelperOutput</code> passed into the <code>ProcessAsync</code> method. As mentioned previously, because the output is cached, the last tag helper to run wins. You fixed that problem with the following code:</p>
<pre><code class="lang-csharp" name="Main">var childContent = output.Content.IsModified ? output.Content.GetContent() : 
    (await output.GetChildContentAsync()).GetContent();
</code></pre><p>The code above checks to see if the content has been modified, and if it has, it gets the content from the output buffer.</p>
</div>
</li>
<li><p>Run the app and verify that the two links work as expected. While it might appear our auto linker tag helper is correct and complete, it has a subtle problem. If the WWW tag helper runs first, the www links will not be correct. Update the code by adding the <code>Order</code> overload to control the order that the tag runs in. The <code>Order</code> property determines the execution order relative to other tag helpers targeting the same element. The default order value is zero and instances with lower values are executed first.</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="5,6,7,8">public class AutoLinkerHttpTagHelper : TagHelper
{
    // This filter must run before the AutoLinkerWwwTagHelper as it searches and replaces http and 
    // the AutoLinkerWwwTagHelper adds http to the markup.
    public override int Order
    {
        get  {  return int.MinValue;   }
    }
</code></pre><p>The above code will guarantee that the HTTP tag helper runs before the WWW tag helper. Change <code>Order</code> to <code>MaxValue</code> and verify that the markup generated for the  WWW tag is incorrect.</p>
</li>
</ol>
<h2 id="inspecting-and-retrieving-child-content">Inspecting and retrieving child content</h2>
<p>The tag helpers provide several properties to retrieve content.</p>
<ul>
<li>The result of <code>GetChildContentAsync</code> can be appended to <code>output.Content</code>.</li>
<li>You can inspect the result of <code>GetChildContentAsync</code> with <code>GetContent</code>.</li>
<li>If you modify <code>output.Content</code>, the TagHelper body will not be executed or rendered unless you call <code>GetChildContentAsync</code> as in our auto-linker sample:</li>
</ul>
<pre><code class="lang-csharp" name="Main" highlight-lines="5,6,10">public class AutoLinkerHttpTagHelper : TagHelper
{
    public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
    {
        var childContent = output.Content.IsModified ? output.Content.GetContent() :
            (await output.GetChildContentAsync()).GetContent();

        // Find Urls in the content and replace them with their anchor tag equivalent.
        output.Content.SetHtmlContent(Regex.Replace(
             childContent,
             @&quot;\b(?:https?://)(\S+)\b&quot;,
              &quot;&lt;a target=\&quot;_blank\&quot; href=\&quot;$0\&quot;&gt;$0&lt;/a&gt;&quot;));  // http link version}
    }
}
</code></pre><ul>
<li>Multiple calls to <code>GetChildContentAsync</code> will return the same value and will not re-execute the <code>TagHelper</code> body unless you pass in a false parameter indicating  not use the cached result.</li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/aspnet/Docs/blob/w/riande/RP-EF/aspnetcore/mvc/views/tag-helpers/authoring.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2015-2017 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
