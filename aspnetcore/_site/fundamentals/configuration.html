<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Configuration in ASP.NET Core </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Configuration in ASP.NET Core ">
    <meta name="generator" content="docfx 2.24.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="fundamentals/configuration">
<h1 id="configuration-in-aspnet-core">Configuration in ASP.NET Core</h1>

<p><a href="https://twitter.com/RickAndMSFT">Rick Anderson</a>, <a href="http://intellitect.com/author/mark-michaelis/">Mark Michaelis</a>, <a href="https://ardalis.com/">Steve Smith</a>, <a href="https://github.com/danroth27">Daniel Roth</a>, and <a href="https://github.com/guardrex">Luke Latham</a></p>
<p>The Configuration API provides a way of configuring an app based on a list of name-value pairs. Configuration is read at runtime from multiple sources. The name-value pairs can be grouped into a multi-level hierarchy. There are configuration providers for:</p>
<ul>
<li>File formats (INI, JSON, and XML)</li>
<li>Command-line arguments</li>
<li>Environment variables</li>
<li>In-memory .NET objects</li>
<li>An encrypted user store</li>
<li><a class="xref" href="../security/key-vault-configuration.html">Azure Key Vault</a></li>
<li>Custom providers, which you install or create</li>
</ul>
<p>Each configuration value maps to a string key. There&#39;s built-in binding support to deserialize settings into a custom <a href="https://wikipedia.org/wiki/Plain_Old_CLR_Object">POCO</a> object (a simple .NET class with properties).</p>
<p><a href="https://github.com/aspnet/docs/tree/master/aspnetcore/fundamentals/configuration/sample">View or download sample code</a></p>
<h2 id="simple-configuration">Simple configuration</h2>
<p>The following console app uses the JSON configuration provider:</p>
<pre><code class="lang-csharp" name="Main">using System;
using System.IO;
using Microsoft.Extensions.Configuration;

public class Program
{
    public static IConfigurationRoot Configuration { get; set; }

    public static void Main(string[] args = null)
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile(&quot;appsettings.json&quot;);

        Configuration = builder.Build();

        Console.WriteLine($&quot;option1 = {Configuration[&quot;option1&quot;]}&quot;);
        Console.WriteLine($&quot;option2 = {Configuration[&quot;option2&quot;]}&quot;);
        Console.WriteLine(
            $&quot;suboption1 = {Configuration[&quot;subsection:suboption1&quot;]}&quot;);
        Console.WriteLine();

        Console.WriteLine(&quot;Wizards:&quot;);
        Console.Write($&quot;{Configuration[&quot;wizards:0:Name&quot;]}, &quot;);
        Console.WriteLine($&quot;age {Configuration[&quot;wizards:0:Age&quot;]}&quot;);
        Console.Write($&quot;{Configuration[&quot;wizards:1:Name&quot;]}, &quot;);
        Console.WriteLine($&quot;age {Configuration[&quot;wizards:1:Age&quot;]}&quot;);
        Console.WriteLine();

        Console.WriteLine(&quot;Press a key...&quot;);
        Console.ReadKey();
    }
}
</code></pre><p>The app reads and displays the following configuration settings:</p>
<pre><code class="lang-json" name="Main">{
  &quot;option1&quot;: &quot;value1_from_json&quot;,
  &quot;option2&quot;: 2,

  &quot;subsection&quot;: {
    &quot;suboption1&quot;: &quot;subvalue1_from_json&quot;
  },
  &quot;wizards&quot;: [
    {
      &quot;Name&quot;: &quot;Gandalf&quot;,
      &quot;Age&quot;: &quot;1000&quot;
    },
    {
      &quot;Name&quot;: &quot;Harry&quot;,
      &quot;Age&quot;: &quot;17&quot;
    }
  ]
}
</code></pre><p>Configuration consists of a hierarchical list of name-value pairs in which the nodes are separated by a colon. To retrieve a value, access the <code>Configuration</code> indexer with the corresponding item&#39;s key:</p>
<pre><code class="lang-csharp">Console.WriteLine($&quot;option1 = {Configuration[&quot;subsection:suboption1&quot;]}&quot;);
</code></pre><p>To work with arrays in JSON-formatted configuration sources, use a array index as part of the colon-separated string. The following example gets the name of the first item in the preceding <code>wizards</code> array:</p>
<pre><code class="lang-csharp">Console.Write($&quot;{Configuration[&quot;wizards:0:Name&quot;]}, &quot;);
</code></pre><p>Name-value pairs written to the built in <code>Configuration</code> providers are <strong>not</strong> persisted, however, you can create a custom provider that saves values. See <a class="xref" href="configuration.html#custom-config-providers">custom configuration provider</a>.</p>
<p>The preceding sample uses the configuration indexer to read values. To access configuration outside of <code>Startup</code>, use the <a class="xref" href="configuration.html#options-config-objects">options pattern</a>. The <em>options pattern</em> is shown later in this article.</p>
<p>It&#39;s typical to have different configuration settings for different environments, for example, development, test, and production. The <code>CreateDefaultBuilder</code> extension method in an ASP.NET Core 2.x app (or using <code>AddJsonFile</code> and <code>AddEnvironmentVariables</code> directly in an ASP.NET Core 1.x app) adds configuration providers for reading JSON files and system configuration sources:</p>
<ul>
<li><em>appsettings.json</em></li>
<li><em>appsettings.&lt;EnvironmentName&gt;.json</em></li>
<li>environment variables</li>
</ul>
<p>See <a href="https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.configuration.jsonconfigurationextensions">AddJsonFile</a> for an explanation of the parameters. <code>reloadOnChange</code> is only supported in ASP.NET Core 1.1 and higher. </p>
<p>Configuration sources are read in the order they are specified. In the code above, the environment variables are read last. Any configuration values set through the environment would replace those set in the two previous providers.</p>
<p>The environment is typically set to one of <code>Development</code>, <code>Staging</code>, or <code>Production</code>. See <a href="environments.html">Working with Multiple Environments</a> for more information.</p>
<p>Configuration considerations:</p>
<ul>
<li><code>IOptionsSnapshot</code> can reload configuration data when it changes. Use <code>IOptionsSnapshot</code> if you need to reload configuration data.  See <a href="#ioptionssnapshot">IOptionsSnapshot</a> for more information.</li>
<li>Configuration keys are case insensitive.</li>
<li>A best practice is to specify environment variables last, so that the local environment can override anything set in deployed configuration files.</li>
<li><strong>Never</strong> store passwords or other sensitive data in configuration provider code or in plain text configuration files. Don&#39;t use production secrets in your development or test environments. Instead, specify secrets outside the project tree, so they cannot be accidentally committed into your repository. Learn more about <a href="environments.html">Working with Multiple Environments</a> and managing <a href="../security/app-secrets.html">safe storage of app secrets during development</a>.</li>
<li>If <code>:</code> cannot be used in environment variables in your system,  replace <code>:</code>  with <code>__</code> (double underscore).</li>
</ul>
<p><a name="options-config-objects"></a></p>
<h2 id="using-options-and-configuration-objects">Using Options and configuration objects</h2>
<p>The options pattern uses custom options classes to represent a group of related settings. We recommended that you create decoupled classes for each feature within your app. Decoupled classes follow:</p>
<ul>
<li>The <a href="http://deviq.com/interface-segregation-principle/">Interface Segregation Principle (ISP)</a> : Classes depend only on the configuration settings they use.</li>
<li><a href="http://deviq.com/separation-of-concerns/">Separation of Concerns</a> : Settings for different parts of your app are not dependent or coupled with one another.</li>
</ul>
<p>The options class must be non-abstract with a public parameterless constructor. For example:</p>
<pre><code class="lang-csharp" name="Main">namespace UsingOptions.Models
{
    public class MyOptions
    {
        public MyOptions()
        {
            // Set default value.
            Option1 = &quot;value1_from_ctor&quot;;
        }
        public string Option1 { get; set; }
        public int Option2 { get; set; } = 5;
    }
}
</code></pre><p><a name="options-example"></a></p>
<p>In the following code, the JSON configuration provider is enabled. The <code>MyOptions</code> class is added to the service container and bound to configuration.</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="8,20-21">public class Startup
{
    public Startup(IHostingEnvironment env)
    {
        // Set up configuration sources.
        var builder = new ConfigurationBuilder()
            .SetBasePath(env.ContentRootPath)
            .AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true);

        Configuration = builder.Build();
    }

    public IConfigurationRoot Configuration { get; set; }

    public void ConfigureServices(IServiceCollection services)
    {
        // Adds services required for using options.
        services.AddOptions();

        // Register the IConfiguration instance which MyOptions binds against.
        services.Configure&lt;MyOptions&gt;(Configuration);

        // Add framework services.
        services.AddMvc();
    }
</code></pre><p>The following <a href="../mvc/controllers/index.html">controller</a>  uses <a class="xref" href="dependency-injection.html#what-is-dependency-injection">constructor Dependency Injection</a> on <a href="https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.options.ioptions-1"><code>IOptions&lt;TOptions&gt;</code></a> to access settings:</p>
<pre><code class="lang-csharp" name="Main">public class HomeController : Controller
{
    private readonly MyOptions _options;

    public HomeController(IOptions&lt;MyOptions&gt; optionsAccessor)
    {
        _options = optionsAccessor.Value;
    }

    public IActionResult Index()
    {
        var option1 = _options.Option1;
        var option2 = _options.Option2;
        return Content($&quot;option1 = {option1}, option2 = {option2}&quot;);
    }
}
</code></pre><p>With the following <em>appsettings.json</em> file:</p>
<pre><code class="lang-json" name="Main">{
  &quot;option1&quot;: &quot;value1_from_json&quot;,
  &quot;option2&quot;: 2
}
</code></pre><p>The <code>HomeController.Index</code> method returns <code>option1 = value1_from_json, option2 = 2</code>.</p>
<p>Typical apps won&#39;t bind the entire configuration to a single options file. Later on I&#39;ll show how to use <code>GetSection</code> to bind to a section.</p>
<p>In the following code, a second <code>IConfigureOptions&lt;TOptions&gt;</code> service is added to the service container. It uses a delegate to configure the binding with <code>MyOptions</code>.</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="9-13">public void ConfigureServices(IServiceCollection services)
{
    // Adds services required for using options.
    services.AddOptions();

    // Register the ConfigurationBuilder instance which MyOptions binds against.
    services.Configure&lt;MyOptions&gt;(Configuration);

    // Registers the following lambda used to configure options.
    services.Configure&lt;MyOptions&gt;(myOptions =&gt;
    {
        myOptions.Option1 = &quot;value1_from_action&quot;;
    });

    // Add framework services.
    services.AddMvc();
}
</code></pre><p>You can add multiple configuration providers. Configuration providers are available in NuGet packages. They are applied in order they are registered.</p>
<p>Each call to <code>Configure&lt;TOptions&gt;</code> adds an <code>IConfigureOptions&lt;TOptions&gt;</code> service to the service container. In the preceding example, the values of <code>Option1</code> and <code>Option2</code> are both specified in <em>appsettings.json</em> -- but the value of <code>Option1</code> is overridden by the configured delegate. </p>
<p>When more than one configuration service is enabled, the last configuration source specified &quot;wins&quot; (sets the configuration value). In the preceding code, the <code>HomeController.Index</code> method returns <code>option1 = value1_from_action, option2 = 2</code>.</p>
<p>When you bind options to configuration, each property in your options type is bound to a configuration key of the form <code>property[:sub-property:]</code>. For example, the <code>MyOptions.Option1</code> property is bound to the key <code>Option1</code>, which is read from the <code>option1</code> property in <em>appsettings.json</em>. A sub-property sample is shown later in this article.</p>
<p>In the following code, a third <code>IConfigureOptions&lt;TOptions&gt;</code> service is added to the service container. It binds <code>MySubOptions</code> to the section <code>subsection</code> of the <em>appsettings.json</em> file:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="16-17">public void ConfigureServices(IServiceCollection services)
{
    // Adds services required for using options.
    services.AddOptions();

    // Configure with Microsoft.Extensions.Options.ConfigurationExtensions
    // Binding the whole configuration should be rare, subsections are more typical.
    services.Configure&lt;MyOptions&gt;(Configuration);

    // Configure MyOptions using code.
    services.Configure&lt;MyOptions&gt;(myOptions =&gt;
    {
        myOptions.Option1 = &quot;value1_from_action&quot;;
    });

    // Configure using a sub-section of the appsettings.json file.
    services.Configure&lt;MySubOptions&gt;(Configuration.GetSection(&quot;subsection&quot;));

    // Add framework services.
    services.AddMvc();
}
</code></pre><p>Note: This extension method requires the <code>Microsoft.Extensions.Options.ConfigurationExtensions</code> NuGet package.</p>
<p>Using the following <em>appsettings.json</em> file:</p>
<pre><code class="lang-json" name="Main">{
  &quot;option1&quot;: &quot;value1_from_json&quot;,
  &quot;option2&quot;: -1,
  &quot;subsection&quot;: {
    &quot;suboption1&quot;: &quot;subvalue1_from_json&quot;,
    &quot;suboption2&quot;: 200
  }
}
</code></pre><p>The <code>MySubOptions</code> class:</p>
<pre><code class="lang-csharp" name="Main">public class MySubOptions
{
    public MySubOptions()
    {
        // Set default values.
        SubOption1 = &quot;value1_from_ctor&quot;;
        SubOption2 = 5;
    }
    public string SubOption1 { get; set; }
    public int SubOption2 { get; set; }
}
</code></pre><p>With the following <code>Controller</code>:</p>
<pre><code class="lang-csharp" name="Main">public class HomeController : Controller
{
    private readonly MySubOptions _subOptions;

    public HomeController(IOptions&lt;MySubOptions&gt; subOptionsAccessor)
    {
        _subOptions = subOptionsAccessor.Value;
    }

    public IActionResult Index()
    {
        var subOption1 = _subOptions.SubOption1;
        var subOption2 = _subOptions.SubOption2;
        return Content($&quot;subOption1 = {subOption1}, subOption2 = {subOption2}&quot;);
    }
}
</code></pre><p><code>subOption1 = subvalue1_from_json, subOption2 = 200</code> is returned.</p>
<p>You can also supply options in a view model or inject <code>IOptions&lt;TOptions&gt;</code> directly into a view:</p>
<pre><code class="lang-html" name="Main" highlight-lines="3-4,16-17,20-21">@using Microsoft.Extensions.Options
@using UsingOptions.Models
@model MyOptions
@inject IOptions&lt;MyOptions&gt; OptionsAccessor

&lt;!DOCTYPE html&gt;
&lt;!-- This view works with HomeController3.cs --&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;title&gt;Using Options sample app&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Options&lt;/h1&gt;

    &lt;h2&gt;Options provided by the model&lt;/h2&gt;
    &lt;p&gt;&lt;b&gt;Option1:&lt;/b&gt; @Model.Option1&lt;/p&gt;
    &lt;p&gt;&lt;b&gt;Option2:&lt;/b&gt; @Model.Option2&lt;/p&gt;

    &lt;h2&gt;Options injected into the view&lt;/h2&gt;
    &lt;p&gt;&lt;b&gt;Option1:&lt;/b&gt; @OptionsAccessor.Value.Option1&lt;/p&gt;
    &lt;p&gt;&lt;b&gt;Option2:&lt;/b&gt; @OptionsAccessor.Value.Option2&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><a name="in-memory-provider"></a></p>
<h2 id="ioptionssnapshot">IOptionsSnapshot</h2>
<p><em>Requires ASP.NET Core 1.1 or higher.</em></p>
<p><code>IOptionsSnapshot</code> supports reloading configuration data when the configuration file has changed. It has minimal overhead. Using <code>IOptionsSnapshot</code> with <code>reloadOnChange: true</code>, the options are bound to <code>IConfiguration</code> and reloaded when changed.</p>
<p>The following sample demonstrates how a new <code>IOptionsSnapshot</code> is created after <em>config.json</em> changes. Requests to the server will return the same time when <em>config.json</em> has <strong>not</strong> changed. The first request after <em>config.json</em> changes will show a new time.</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="1-9,13-18,32,33,52,53">public class TimeOptions
{
    // Records the time when the options are created.
    public DateTime CreationTime { get; set; } = DateTime.Now;

    // Bound to config. Changes to the value of &quot;Message&quot;
    // in config.json will be reflected in this property.
    public string Message { get; set; }
}

public class Controller
{
    public readonly TimeOptions _options;

    public Controller(IOptionsSnapshot&lt;TimeOptions&gt; options)
    {
        _options = options.Value;
    }

    public Task DisplayTimeAsync(HttpContext context)
    {
        return context.Response.WriteAsync(_options.Message + _options.CreationTime);
    }
}

public class Startup
{
    public Startup(IHostingEnvironment env)
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            // reloadOnChange: true is required for config changes to be detected.
            .AddJsonFile(&quot;config.json&quot;, optional: false, reloadOnChange: true)
            .AddEnvironmentVariables();
        Configuration = builder.Build();
    }

    public IConfigurationRoot Configuration { get; set; }

    public void Configure(IApplicationBuilder app)
    {
        // Simple mockup of a simple per request controller that writes
        // the creation time and message of TimeOptions.
        app.Run(DisplayTimeAsync);
    }

    public void ConfigureServices(IServiceCollection services)
    {
        // Simple mockup of a simple per request controller.
        services.AddScoped&lt;Controller&gt;();

        // Binds config.json to the options and setups the change tracking.
        services.Configure&lt;TimeOptions&gt;(Configuration.GetSection(&quot;Time&quot;));
    }

    public Task DisplayTimeAsync(HttpContext context)
    {
        context.Response.ContentType = &quot;text/plain&quot;;
        return context.RequestServices.GetRequiredService&lt;Controller&gt;().DisplayTimeAsync(context);
    }

    public static void Main(string[] args)
    {
        var host = new WebHostBuilder()
            .UseKestrel()
            .UseIISIntegration()
            .UseStartup&lt;Startup&gt;()
            .Build();
        host.Run();
    }
}
</code></pre><p>The following image shows the server output:</p>
<p><img src="configuration/_static/first.png" alt="browser image showing &quot;Last Updated: 11/22/2016 4:43 PM&quot;"></p>
<p>Refreshing the browser doesn&#39;t change the message value or time displayed (when <em>config.json</em> has not changed).</p>
<p>Change and save the  <em>config.json</em> and then refresh the browser:</p>
<p><img src="configuration/_static/change.png" alt="browser image showing &quot;Last Updated to,e: 11/22/2016 4:53 PM&quot;"></p>
<h2 id="in-memory-provider-and-binding-to-a-poco-class">In-memory provider and binding to a POCO class</h2>
<p>The following sample shows how to use the in-memory provider and bind to a class:</p>
<pre><code class="lang-csharp" name="Main">using System;
using System.Collections.Generic;
using Microsoft.Extensions.Configuration;

public class Program
{   
    public static IConfigurationRoot Configuration { get; set; }

    public static void Main(string[] args = null)
    {
        var dict = new Dictionary&lt;string, string&gt;
            {
                {&quot;Profile:MachineName&quot;, &quot;Rick&quot;},
                {&quot;App:MainWindow:Height&quot;, &quot;11&quot;},
                {&quot;App:MainWindow:Width&quot;, &quot;11&quot;},
                {&quot;App:MainWindow:Top&quot;, &quot;11&quot;},
                {&quot;App:MainWindow:Left&quot;, &quot;11&quot;}
            };

        var builder = new ConfigurationBuilder();
        builder.AddInMemoryCollection(dict);

        Configuration = builder.Build();

        Console.WriteLine($&quot;Hello {Configuration[&quot;Profile:MachineName&quot;]}&quot;);

        var window = new MyWindow();
        Configuration.GetSection(&quot;App:MainWindow&quot;).Bind(window);
        Console.WriteLine($&quot;Left {window.Left}&quot;);
        Console.WriteLine();

        Console.WriteLine(&quot;Press any key...&quot;);
        Console.ReadKey();
    }
}
</code></pre><p>Configuration values are returned as strings, but binding enables the construction of objects. Binding allows you to retrieve POCO objects or even entire object graphs. The following sample shows how to bind to <code>MyWindow</code> and use the options pattern with a ASP.NET Core MVC app:</p>
<pre><code class="lang-csharp" name="Main">namespace WebConfigBind
{
    public class MyWindow
    {
        public int Height { get; set; }
        public int Width { get; set; }
        public int Top { get; set; }
        public int Left { get; set; }
    }
}
</code></pre><pre><code class="lang-json" name="Main">{
  &quot;AppConfiguration&quot;: {
    &quot;MainWindow&quot;: {
      &quot;Height&quot;: &quot;400&quot;,
      &quot;Width&quot;: &quot;600&quot;,
      &quot;Top&quot;: &quot;5&quot;,
      &quot;Left&quot;: &quot;11&quot;
    }
  }
}
</code></pre><p>Bind the custom class in <code>ConfigureServices</code> when building the host:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="3-4">.ConfigureServices(services =&gt;
{
    services.Configure&lt;MyWindow&gt;(
        Configuration.GetSection(&quot;AppConfiguration:MainWindow&quot;));
    services.AddMvc();
})
</code></pre><p>Display the settings from the <code>HomeController</code>:</p>
<pre><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Options;

namespace WebConfigBind
{
    public class HomeController : Controller
    {
        private readonly IOptions&lt;MyWindow&gt; _optionsAccessor;

        public HomeController(IOptions&lt;MyWindow&gt; optionsAccessor)
        {
            _optionsAccessor = optionsAccessor;
        }

        public IActionResult Index()
        {
            var height = _optionsAccessor.Value.Height;
            var width = _optionsAccessor.Value.Width;
            var left = _optionsAccessor.Value.Left;
            var top = _optionsAccessor.Value.Top;

            return Content($&quot;height = {height}, width = {width}, &quot; + 
                $&quot;left = {left}, top = {top}&quot;);
        }
    }
}
</code></pre><h3 id="getvalue">GetValue</h3>
<p>The following sample demonstrates the <a href="https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.configuration.configurationbinder#Microsoft_Extensions_Configuration_ConfigurationBinder_GetValue_Microsoft_Extensions_Configuration_IConfiguration_System_Type_System_String_System_Object_">GetValue<t></t></a> extension method:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="27-29">using System;
using System.Collections.Generic;
using Microsoft.Extensions.Configuration;

public class Program
{   
    public static IConfigurationRoot Configuration { get; set; }

    public static void Main(string[] args = null)
    {
        var dict = new Dictionary&lt;string, string&gt;
            {
                {&quot;Profile:MachineName&quot;, &quot;Rick&quot;},
                {&quot;App:MainWindow:Height&quot;, &quot;11&quot;},
                {&quot;App:MainWindow:Width&quot;, &quot;11&quot;},
                {&quot;App:MainWindow:Top&quot;, &quot;11&quot;},
                {&quot;App:MainWindow:Left&quot;, &quot;11&quot;}
            };

        var builder = new ConfigurationBuilder();
        builder.AddInMemoryCollection(dict);

        Configuration = builder.Build();

        Console.WriteLine($&quot;Hello {Configuration[&quot;Profile:MachineName&quot;]}&quot;);

        // Show GetValue overload and set the default value to 80
        // Requires NuGet package &quot;Microsoft.Extensions.Configuration.Binder&quot;
        var left = Configuration.GetValue&lt;int&gt;(&quot;App:MainWindow:Left&quot;, 80);
        Console.WriteLine($&quot;Left {left}&quot;);

        var window = new MyWindow();
        Configuration.GetSection(&quot;App:MainWindow&quot;).Bind(window);
        Console.WriteLine($&quot;Left {window.Left}&quot;);
        Console.WriteLine();

        Console.WriteLine(&quot;Press a key...&quot;);
        Console.ReadKey();
    }
}
</code></pre><p>The ConfigurationBinder&#39;s <code>GetValue&lt;T&gt;</code> method allows you to specify a default value (80 in the sample). <code>GetValue&lt;T&gt;</code> is for simple scenarios and does not bind to entire sections. <code>GetValue&lt;T&gt;</code> gets scalar values from <code>GetSection(key).Value</code> converted to a specific type.</p>
<h2 id="binding-to-an-object-graph">Binding to an object graph</h2>
<p>You can recursively bind to each object in a class. Consider the following <code>AppOptions</code> class:</p>
<pre><code class="lang-csharp" name="Main">public class AppOptions
{
    public Window Window { get; set; }
    public Connection Connection { get; set; }
    public Profile Profile { get; set; }
}

public class Window
{
    public int Height { get; set; }
    public int Width { get; set; }
}

public class Connection
{
    public string Value { get; set; }
}

public class Profile
{
    public string Machine { get; set; }
}
</code></pre><p>The following sample binds to the <code>AppOptions</code> class:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="15-16">using System;
using System.IO;
using Microsoft.Extensions.Configuration;

public class Program
{
    public static void Main(string[] args = null)
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile(&quot;appsettings.json&quot;);

        var config = builder.Build();

        var appConfig = new AppOptions();
        config.GetSection(&quot;App&quot;).Bind(appConfig);

        Console.WriteLine($&quot;Height {appConfig.Window.Height}&quot;);
        Console.WriteLine();

        Console.WriteLine(&quot;Press a key...&quot;);
        Console.ReadKey();
    }
}
</code></pre><p><strong>ASP.NET Core 1.1</strong> and higher can use  <code>Get&lt;T&gt;</code>, which works with entire sections. <code>Get&lt;T&gt;</code> can be more convienent than using <code>Bind</code>. The following code shows how to use <code>Get&lt;T&gt;</code> with the sample above:</p>
<pre><code class="lang-csharp">var appConfig = config.GetSection(&quot;App&quot;).Get&lt;AppOptions&gt;();
</code></pre><p>Using the following <em>appsettings.json</em> file:</p>
<pre><code class="lang-json" name="Main">{
  &quot;App&quot;: {
    &quot;Profile&quot;: {
      &quot;Machine&quot;: &quot;Rick&quot;
    },
    &quot;Connection&quot;: {
      &quot;Value&quot;: &quot;connectionstring&quot;
    },
    &quot;Window&quot;: {
      &quot;Height&quot;: &quot;11&quot;,
      &quot;Width&quot;: &quot;11&quot;
    }
  }
}
</code></pre><p>The program displays <code>Height 11</code>.</p>
<p>The following code can be used to unit test the configuration:</p>
<pre><code class="lang-csharp">[Fact]
public void CanBindObjectTree()
{
    var dict = new Dictionary&lt;string, string&gt;
        {
            {&quot;App:Profile:Machine&quot;, &quot;Rick&quot;},
            {&quot;App:Connection:Value&quot;, &quot;connectionstring&quot;},
            {&quot;App:Window:Height&quot;, &quot;11&quot;},
            {&quot;App:Window:Width&quot;, &quot;11&quot;}
        };
    var builder = new ConfigurationBuilder();
    builder.AddInMemoryCollection(dict);
    var config = builder.Build();

    var options = new AppOptions();
    config.GetSection(&quot;App&quot;).Bind(options);

    Assert.Equal(&quot;Rick&quot;, options.Profile.Machine);
    Assert.Equal(11, options.Window.Height);
    Assert.Equal(11, options.Window.Width);
    Assert.Equal(&quot;connectionstring&quot;, options.Connection.Value);
}
</code></pre><p><a name="custom-config-providers"></a></p>
<h2 id="basic-sample-of-entity-framework-custom-provider">Basic sample of Entity Framework custom provider</h2>
<p>In this section, a basic configuration provider that reads name-value pairs from a database using EF is created. </p>
<p>Define a <code>ConfigurationValue</code> entity for storing configuration values in the database:</p>
<pre><code class="lang-csharp" name="Main">public class ConfigurationValue
{
    public string Id { get; set; }
    public string Value { get; set; }
}
</code></pre><p>Add a <code>ConfigurationContext</code> to store and access the configured values:</p>
<pre><code class="lang-csharp" name="Main">public class ConfigurationContext : DbContext
{
    public ConfigurationContext(DbContextOptions options) : base(options)
    {
    }

    public DbSet&lt;ConfigurationValue&gt; Values { get; set; }
}
</code></pre><p>Create an class that implements <a href="https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.configuration.iconfigurationsource">IConfigurationSource</a>:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="7">using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;

namespace CustomConfigurationProvider
{
    public class EFConfigSource : IConfigurationSource
    {
        private readonly Action&lt;DbContextOptionsBuilder&gt; _optionsAction;

        public EFConfigSource(Action&lt;DbContextOptionsBuilder&gt; optionsAction)
        {
            _optionsAction = optionsAction;
        }

        public IConfigurationProvider Build(IConfigurationBuilder builder)
        {
            return new EFConfigProvider(_optionsAction);
        }
    }
}
</code></pre><p>Create the custom configuration provider by inheriting from <a href="https://docs.microsoft.com/aspnet/core/api/microsoft.extensions.configuration.configurationprovider">ConfigurationProvider</a>.  The configuration provider initializes the database when it&#39;s empty:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="9,18-31,38-39">using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;

namespace CustomConfigurationProvider
{
    public class EFConfigProvider : ConfigurationProvider
    {
        public EFConfigProvider(Action&lt;DbContextOptionsBuilder&gt; optionsAction)
        {
            OptionsAction = optionsAction;
        }

        Action&lt;DbContextOptionsBuilder&gt; OptionsAction { get; }

        // Load config data from EF DB.
        public override void Load()
        {
            var builder = new DbContextOptionsBuilder&lt;ConfigurationContext&gt;();
            OptionsAction(builder);

            using (var dbContext = new ConfigurationContext(builder.Options))
            {
                dbContext.Database.EnsureCreated();
                Data = !dbContext.Values.Any()
                    ? CreateAndSaveDefaultValues(dbContext)
                    : dbContext.Values.ToDictionary(c =&gt; c.Id, c =&gt; c.Value);
            }
        }

        private static IDictionary&lt;string, string&gt; CreateAndSaveDefaultValues(
            ConfigurationContext dbContext)
        {
            var configValues = new Dictionary&lt;string, string&gt;
                {
                    { &quot;key1&quot;, &quot;value_from_ef_1&quot; },
                    { &quot;key2&quot;, &quot;value_from_ef_2&quot; }
                };
            dbContext.Values.AddRange(configValues
                .Select(kvp =&gt; new ConfigurationValue { Id = kvp.Key, Value = kvp.Value })
                .ToArray());
            dbContext.SaveChanges();
            return configValues;
        }
    }
}
</code></pre><p>The highlighted values from the database (&quot;value_from_ef_1&quot; and &quot;value_from_ef_2&quot;) are displayed when the sample is run.</p>
<p>You can add an <code>EFConfigSource</code> extension method for adding the configuration source:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="12">using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;

namespace CustomConfigurationProvider
{
    public static class EntityFrameworkExtensions
    {
        public static IConfigurationBuilder AddEntityFrameworkConfig(
            this IConfigurationBuilder builder, Action&lt;DbContextOptionsBuilder&gt; setup)
        {
            return builder.Add(new EFConfigSource(setup));
        }
    }
}
</code></pre><p>The following code shows how to use the custom <code>EFConfigProvider</code>:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="21-26">using System;
using System.IO;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using CustomConfigurationProvider;

public static class Program
{
    public static void Main()
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile(&quot;appsettings.json&quot;);

        var connectionStringConfig = builder.Build();

        var config = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            // Add &quot;appsettings.json&quot; to bootstrap EF config.
            .AddJsonFile(&quot;appsettings.json&quot;)
            // Add the EF configuration provider, which will override any
            // config made with the JSON provider.
            .AddEntityFrameworkConfig(options =&gt;
                options.UseSqlServer(connectionStringConfig.GetConnectionString(
                    &quot;DefaultConnection&quot;))
            )
            .Build();

        Console.WriteLine(&quot;key1={0}&quot;, config[&quot;key1&quot;]);
        Console.WriteLine(&quot;key2={0}&quot;, config[&quot;key2&quot;]);
        Console.WriteLine(&quot;key3={0}&quot;, config[&quot;key3&quot;]);
        Console.WriteLine();

        Console.WriteLine(&quot;Press a key...&quot;);
        Console.ReadKey();
    }
}
</code></pre><p>Note the sample adds the custom <code>EFConfigProvider</code> after the JSON provider, so any settings from the database will override settings from the <em>appsettings.json</em> file.</p>
<p>Using the following <em>appsettings.json</em> file:</p>
<pre><code class="lang-json" name="Main">{
  &quot;ConnectionStrings&quot;: {
    &quot;DefaultConnection&quot;: &quot;Server=(localdb)\\mssqllocaldb;Database=CustomConfigurationProvider;Trusted_Connection=True;MultipleActiveResultSets=true&quot;
  },
  &quot;key1&quot;: &quot;value_from_json_1&quot;,
  &quot;key2&quot;: &quot;value_from_json_2&quot;,
  &quot;key3&quot;: &quot;value_from_json_3&quot;
}
</code></pre><p>The following is displayed:</p>
<pre><code class="lang-console">key1=value_from_ef_1
key2=value_from_ef_2
key3=value_from_json_3
</code></pre><h2 id="commandline-configuration-provider">CommandLine configuration provider</h2>
<p>The <a href="/aspnet/core/api/microsoft.extensions.configuration.commandline.commandlineconfigurationprovider">CommandLine configuration provider</a> receives command-line argument key-value pairs for configuration at runtime.</p>
<p><a href="https://github.com/aspnet/docs/tree/master/aspnetcore/fundamentals/configuration/sample/CommandLine">View or download the CommandLine configuration sample</a></p>
<h3 id="setting-up-the-provider">Setting up the provider</h3>
<div class="tabGroup" id="tabgroup_grmnDckdk3">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_grmnDckdk3_basicconfiguration" role="tab" aria-controls="tabpanel_grmnDckdk3_basicconfiguration" data-tab="basicconfiguration" tabindex="0" aria-selected="true">Basic Configuration</a>
</li>
<li role="presentation">
<a href="#tabpanel_grmnDckdk3_aspnetcore2x" role="tab" aria-controls="tabpanel_grmnDckdk3_aspnetcore2x" data-tab="aspnetcore2x" tabindex="-1">ASP.NET Core 2.x</a>
</li>
<li role="presentation">
<a href="#tabpanel_grmnDckdk3_aspnetcore1x" role="tab" aria-controls="tabpanel_grmnDckdk3_aspnetcore1x" data-tab="aspnetcore1x" tabindex="-1">ASP.NET Core 1.x</a>
</li>
</ul>
<section id="tabpanel_grmnDckdk3_basicconfiguration" role="tabpanel" data-tab="basicconfiguration">
<p>To activate command-line configuration, call the <code>AddCommandLine</code> extension method on an instance of <a href="/api/microsoft.extensions.configuration.configurationbuilder">ConfigurationBuilder</a>:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="18,21">using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Extensions.Configuration;

public class Program
{
    public static IConfigurationRoot Configuration { get; set; }

    public static void Main(string[] args = null)
    {
        var dict = new Dictionary&lt;string, string&gt;
            {
                {&quot;Profile:MachineName&quot;, &quot;MairaPC&quot;},
                {&quot;App:MainWindow:Left&quot;, &quot;1980&quot;}
            };

        var builder = new ConfigurationBuilder();

        builder.AddInMemoryCollection(dict)
            .AddCommandLine(args);

        Configuration = builder.Build();

        Console.WriteLine($&quot;MachineName: {Configuration[&quot;Profile:MachineName&quot;]}&quot;);
        Console.WriteLine($&quot;Left: {Configuration[&quot;App:MainWindow:Left&quot;]}&quot;);
        Console.WriteLine();

        Console.WriteLine(&quot;Press a key...&quot;);
        Console.ReadKey();
    }
}
</code></pre><p>Running the code, the following output is displayed:</p>
<pre><code class="lang-console">MachineName: MairaPC
Left: 1980
</code></pre><p>Passing argument key-value pairs on the command line changes the values of <code>Profile:MachineName</code> and <code>App:MainWindow:Left</code>:</p>
<pre><code class="lang-console">dotnet run Profile:MachineName=BartPC App:MainWindow:Left=1979
</code></pre><p>The console window displays:</p>
<pre><code class="lang-console">MachineName: BartPC
Left: 1979
</code></pre><p>To override configuration provided by other configuration providers with command-line configuration, call <code>AddCommandLine</code> last on <code>ConfigurationBuilder</code>:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="1,5">var config = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)
    .AddEnvironmentVariables()
    .AddCommandLine(args)
    .Build();
</code></pre></section>
<section id="tabpanel_grmnDckdk3_aspnetcore2x" role="tabpanel" data-tab="aspnetcore2x" aria-hidden="true" hidden="hidden">
<p>Typical ASP.NET Core 2.x apps use the static convenience method <code>CreateDefaultBuilder</code> to build the host:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="12">using Microsoft.AspNetCore;
using Microsoft.AspNetCore.Hosting;

public class Program
{
    public static void Main(string[] args)
    {
        BuildWebHost(args).Run();
    }

    public static IWebHost BuildWebHost(string[] args) =&gt;
        WebHost.CreateDefaultBuilder(args)
            .UseStartup&lt;Startup&gt;()
            .Build();
}
</code></pre><p><code>CreateDefaultBuilder</code> loads optional configuration from <em>appsettings.json</em>, <em>appsettings.{Environment}.json</em>, <a class="xref" href="../security/app-secrets.html">user secrets</a> (in the <code>Development</code> environment), environment variables, and command-line arguments. The CommandLine configuration provider is called last. Calling the provider last allows the command-line arguments passed at runtime to override configuration set by the other configuration providers called earlier.</p>
<p>Note that for <em>appsettings</em> files that <code>reloadOnChange</code> is enabled. Command-line arguments are overridden if a matching configuration value in an <em>appsettings</em> file is changed after the app starts.</p>
<div class="NOTE"><h5>Note</h5><p>As an alternative to using the <code>CreateDefaultBuilder</code> method, creating a host using <a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilder">WebHostBuilder</a> and manually building configuration with <a href="/api/microsoft.extensions.configuration.configurationbuilder">ConfigurationBuilder</a> is supported in ASP.NET Core 2.x. See the ASP.NET Core 1.x tab for more information.</p>
</div>
</section>
<section id="tabpanel_grmnDckdk3_aspnetcore1x" role="tabpanel" data-tab="aspnetcore1x" aria-hidden="true" hidden="hidden">
<p>Create a <a href="/api/microsoft.extensions.configuration.configurationbuilder">ConfigurationBuilder</a> and call the <code>AddCommandLine</code> method to use the CommandLine configuration provider. Calling the provider last allows the command-line arguments passed at runtime to override configuration set by the other configuration providers called earlier. Apply the configuration to <a href="/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilder">WebHostBuilder</a> with the <code>UseConfiguration</code> method:</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="11,15,19">using System.IO;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;

public class Program
{
    public static void Main(string[] args)
    {
        var config = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)
            .AddEnvironmentVariables()
            .AddCommandLine(args)
            .Build();

        var host = new WebHostBuilder()
            .UseConfiguration(config)
            .UseKestrel()
            .Configure(app =&gt;
            {
                app.Run(context =&gt; context.Response.WriteAsync(&quot;Hello World!&quot;));
            })
            .Build();

        host.Run();
    }
}
</code></pre></section>
</div>
<h3 id="arguments">Arguments</h3>
<p>Arguments passed on the command line must conform to one of two formats shown in the following table.</p>
<table>
<thead>
<tr>
<th>Argument format</th>
<th style="text-align:center">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single argument: a key-value pair separated by an equals sign (<code>=</code>)</td>
<td style="text-align:center"><code>key1=value</code></td>
</tr>
<tr>
<td>Sequence of two arguments: a key-value pair separated by a space</td>
<td style="text-align:center"><code>/key1 value1</code></td>
</tr>
</tbody>
</table>
<p><strong>Single argument</strong></p>
<p>The value must follow an equals sign (<code>=</code>). The value can be null (for example, <code>mykey=</code>).</p>
<p>The key may have a prefix.</p>
<table>
<thead>
<tr>
<th>Key prefix</th>
<th style="text-align:center">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>No prefix</td>
<td style="text-align:center"><code>key1=value1</code></td>
</tr>
<tr>
<td>Single dash (<code>-</code>)&#8224;</td>
<td style="text-align:center"><code>-key2=value2</code></td>
</tr>
<tr>
<td>Two dashes (<code>--</code>)</td>
<td style="text-align:center"><code>--key3=value3</code></td>
</tr>
<tr>
<td>Forward slash (<code>/</code>)</td>
<td style="text-align:center"><code>/key4=value4</code></td>
</tr>
</tbody>
</table>
<p>&#8224;A key with a single dash prefix (<code>-</code>) must be provided in <a href="#switch-mappings">switch mappings</a>, described below.</p>
<p>Example command:</p>
<pre><code class="lang-console">dotnet run key1=value1 -key2=value2 --key3=value3 /key4=value4
</code></pre><p>Note: If <code>-key1</code> isn&#39;t present in the <a href="#switch-mappings">switch mappings</a> given to the configuration provider, a <code>FormatException</code> is thrown.</p>
<p><strong>Sequence of two arguments</strong></p>
<p>The value can&#39;t be null and must follow the key separated by a space.</p>
<p>The key must have a prefix.</p>
<table>
<thead>
<tr>
<th>Key prefix</th>
<th style="text-align:center">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single dash (<code>-</code>)&#8224;</td>
<td style="text-align:center"><code>-key1 value1</code></td>
</tr>
<tr>
<td>Two dashes (<code>--</code>)</td>
<td style="text-align:center"><code>--key2 value2</code></td>
</tr>
<tr>
<td>Forward slash (<code>/</code>)</td>
<td style="text-align:center"><code>/key3 value3</code></td>
</tr>
</tbody>
</table>
<p>&#8224;A key with a single dash prefix (<code>-</code>) must be provided in <a href="#switch-mappings">switch mappings</a>, described below.</p>
<p>Example command:</p>
<pre><code class="lang-console">dotnet run -key1 value1 --key2 value2 /key3 value3
</code></pre><p>Note: If <code>-key1</code> isn&#39;t present in the <a href="#switch-mappings">switch mappings</a> given to the configuration provider, a <code>FormatException</code> is thrown.</p>
<h3 id="duplicate-keys">Duplicate keys</h3>
<p>If duplicate keys are provided, the last key-value pair is used.</p>
<h3 id="switch-mappings">Switch mappings</h3>
<p>When manually building configuration with <code>ConfigurationBuilder</code>, you can optionally provide a switch mappings dictionary to the <code>AddCommandLine</code> method. Switch mappings allow you to provide key name replacement logic.</p>
<p>When the switch mappings dictionary is used, the dictionary is checked for a key that matches the key provided by a command-line argument. If the command-line key is found in the dictionary, the dictionary value (the key replacement) is passed back to set the configuration. A switch mapping is required for any command-line key prefixed with a single dash (<code>-</code>).</p>
<p>Switch mappings dictionary key rules:</p>
<ul>
<li>Switches must start with a dash (<code>-</code>) or double-dash (<code>--</code>).</li>
<li>The switch mappings dictionary must not contain duplicate keys.</li>
</ul>
<p>In the following example, the <code>GetSwitchMappings</code> method allows your command-line arguments to use a single dash (<code>-</code>) key prefix and avoid leading subkey prefixes.</p>
<pre><code class="lang-csharp" name="Main" highlight-lines="10-19,32">using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Extensions.Configuration;

public class Program
{
    public static IConfigurationRoot Configuration { get; set; }

    public static Dictionary&lt;string, string&gt; GetSwitchMappings(
        IReadOnlyDictionary&lt;string, string&gt; configurationStrings)
    {
        return configurationStrings.Select(item =&gt;
            new KeyValuePair&lt;string, string&gt;(
                &quot;-&quot; + item.Key.Substring(item.Key.LastIndexOf(&#39;:&#39;) + 1),
                item.Key))
                .ToDictionary(
                    item =&gt; item.Key, item =&gt; item.Value);
    }

    public static void Main(string[] args = null)
    {
        var dict = new Dictionary&lt;string, string&gt;
            {
                {&quot;Profile:MachineName&quot;, &quot;RickPC&quot;},
                {&quot;App:MainWindow:Left&quot;, &quot;1980&quot;}
            };

        var builder = new ConfigurationBuilder();

        builder.AddInMemoryCollection(dict)
            .AddCommandLine(args, GetSwitchMappings(dict));

        Configuration = builder.Build();

        Console.WriteLine($&quot;MachineName: {Configuration[&quot;Profile:MachineName&quot;]}&quot;);
        Console.WriteLine($&quot;Left: {Configuration[&quot;App:MainWindow:Left&quot;]}&quot;);
        Console.WriteLine();

        Console.WriteLine(&quot;Press a key...&quot;);
        Console.ReadKey();
    }
}
</code></pre><p>Without providing command-line arguments, the dictionary provided to <code>AddInMemoryCollection</code> sets the configuration values. Run the app with the following command:</p>
<pre><code class="lang-console">dotnet run
</code></pre><p>The console window displays:</p>
<pre><code class="lang-console">MachineName: RickPC
Left: 1980
</code></pre><p>Use the following to pass in configuration settings:</p>
<pre><code class="lang-console">dotnet run /Profile:MachineName=DahliaPC /App:MainWindow:Left=1984
</code></pre><p>The console window displays:</p>
<pre><code class="lang-console">MachineName: DahliaPC
Left: 1984
</code></pre><p>After the switch mappings dictionary is created, it contains the data shown in the following table.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-MachineName</code></td>
<td><code>Profile:MachineName</code></td>
</tr>
<tr>
<td><code>-Left</code></td>
<td><code>App:MainWindow:Left</code></td>
</tr>
</tbody>
</table>
<p>To demonstrate key switching using the dictionary, run the following command:</p>
<pre><code class="lang-console">dotnet run -MachineName=ChadPC -Left=1988
</code></pre><p>The command-line keys are swapped. The console window displays the configuration values for <code>Profile:MachineName</code> and <code>App:MainWindow:Left</code>:</p>
<pre><code class="lang-console">MachineName: ChadPC
Left: 1988
</code></pre><h2 id="the-webconfig-file">The web.config file</h2>
<p>A <em>web.config</em> file is required when you host the app in IIS or IIS-Express. <em>web.config</em> turns on the AspNetCoreModule in IIS to launch your app. Settings in <em>web.config</em> enable the AspNetCoreModule in IIS to launch your app and configure other IIS settings and modules. If you are using Visual Studio and delete <em>web.config</em>, Visual Studio will create a new one.</p>
<h2 id="additional-notes">Additional notes</h2>
<ul>
<li>Dependency Injection (DI) is not set up until after <code>ConfigureServices</code> is invoked.</li>
<li>The configuration system is not DI aware.</li>
<li><code>IConfiguration</code> has two specializations:<ul>
<li><code>IConfigurationRoot</code>  Used for the root node. Can trigger a reload.</li>
<li><code>IConfigurationSection</code>  Represents a section of configuration values. The <code>GetSection</code> and <code>GetChildren</code> methods return an <code>IConfigurationSection</code>.</li>
</ul>
</li>
</ul>
<h2 id="additional-resources">Additional resources</h2>
<ul>
<li><a href="environments.html">Working with Multiple Environments</a></li>
<li><a href="../security/app-secrets.html">Safe storage of app secrets during development</a></li>
<li><a class="xref" href="hosting.html">Hosting in ASP.NET Core</a></li>
<li><a href="dependency-injection.html">Dependency Injection</a></li>
<li><a class="xref" href="../security/key-vault-configuration.html">Azure Key Vault configuration provider</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/aspnet/Docs/blob/w/riande/RP-EF/aspnetcore/fundamentals/configuration.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2015-2017 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
